/**
 * Workbook Operation Types
 * 
 * Type-safe definitions for all workbook operations that can be executed by the AI system.
 * These operations are generated by AI in response to user prompts and executed by
 * WorkbookOperationExecutor.
 * 
 * Design Principles:
 * - Type-safe: All parameters validated at compile time
 * - Minimal: Only essential parameters, sensible defaults
 * - Composable: Operations can be chained together
 * - Non-breaking: Aligns with existing workbook utils
 * 
 * References:
 * - workbook/types.ts: Cell, CellStyle, WorkbookJSON interfaces
 * - workbook/utils.ts: createWorkbook() function
 * - workbook/hyperformula.ts: hydrateHFFromWorkbook(), recomputeAndPatchCache()
 */

import type { CellDataType, CellStyle } from '../../workbook/types';

/**
 * Base operation interface
 * All operations must have a type property
 */
export interface BaseOperation {
  type: string;
  params: Record<string, any>;
}

// ============================================================================
// Workbook-Level Operations
// ============================================================================

/**
 * Create a new workbook
 * 
 * This is always the first operation in a workflow.
 * Creates a workbook with an optional set of initial sheets.
 * 
 * Example:
 * ```json
 * {
 *   "type": "createWorkbook",
 *   "params": {
 *     "name": "Q1 Budget",
 *     "initialSheets": ["Sales", "Marketing", "Summary"]
 *   }
 * }
 * ```
 */
export interface CreateWorkbookOperation extends BaseOperation {
  type: 'createWorkbook';
  params: {
    /** Workbook name (e.g., "Q1 Budget") */
    name: string;
    /** Optional list of initial sheet names. If omitted, creates one default sheet. */
    initialSheets?: string[];
  };
}

// ============================================================================
// Sheet-Level Operations
// ============================================================================

/**
 * Add a new sheet to the workbook
 * 
 * Example:
 * ```json
 * {
 *   "type": "addSheet",
 *   "params": {
 *     "name": "Operations",
 *     "id": "operations"
 *   }
 * }
 * ```
 */
export interface AddSheetOperation extends BaseOperation {
  type: 'addSheet';
  params: {
    /** Sheet name visible to user (e.g., "Sales") */
    name: string;
    /** Optional sheet ID. If omitted, generated from name (lowercase, underscores). */
    id?: string;
    /** Optional position to insert (0-based index). If omitted, appends to end. */
    position?: number;
  };
}

/**
 * Remove a sheet from the workbook
 * 
 * Example:
 * ```json
 * {
 *   "type": "removeSheet",
 *   "params": {
 *     "sheetId": "temp_sheet"
 *   }
 * }
 * ```
 */
export interface RemoveSheetOperation extends BaseOperation {
  type: 'removeSheet';
  params: {
    /** Sheet ID to remove */
    sheetId: string;
  };
}

/**
 * Rename an existing sheet
 * 
 * Example:
 * ```json
 * {
 *   "type": "renameSheet",
 *   "params": {
 *     "sheetId": "sheet1",
 *     "newName": "Revenue"
 *   }
 * }
 * ```
 */
export interface RenameSheetOperation extends BaseOperation {
  type: 'renameSheet';
  params: {
    /** Sheet ID to rename */
    sheetId: string;
    /** New name for the sheet */
    newName: string;
  };
}

// ============================================================================
// Cell-Level Operations
// ============================================================================

/**
 * Cell value for setCells operation
 * 
 * Supports both data values and formulas.
 * Must specify dataType explicitly.
 */
export interface CellValue {
  /** Cell value (number, string, boolean) - for data cells */
  value?: string | number | boolean | null;
  /** Formula string (without leading =) - for formula cells */
  formula?: string;
  /** Data type (required) */
  dataType: CellDataType;
  /** Optional number format (e.g., "$#,##0", "0.0%", "mm/dd/yyyy") */
  numFmt?: string;
  /** Optional cell styling */
  style?: CellStyle;
}

/**
 * Set multiple cells at once (bulk operation)
 * 
 * This is the most efficient way to set cell values, especially for large datasets.
 * Supports both data values and formulas.
 * 
 * Example:
 * ```json
 * {
 *   "type": "setCells",
 *   "params": {
 *     "sheet": "sales",
 *     "cells": {
 *       "A1": {
 *         "value": "Month",
 *         "dataType": "string",
 *         "style": { "bold": true }
 *       },
 *       "B1": {
 *         "value": "Budget",
 *         "dataType": "string",
 *         "style": { "bold": true }
 *       },
 *       "A2": {
 *         "value": "January",
 *         "dataType": "string"
 *       },
 *       "B2": {
 *         "value": 50000,
 *         "dataType": "number",
 *         "numFmt": "$#,##0"
 *       }
 *     }
 *   }
 * }
 * ```
 */
export interface SetCellsOperation extends BaseOperation {
  type: 'setCells';
  params: {
    /** Sheet name or ID */
    sheet: string;
    /** Map of cell references to cell values */
    cells: Record<string, CellValue>;
  };
}

/**
 * Set a single formula cell
 * 
 * Use this for setting individual formulas. For multiple cells, prefer setCells.
 * 
 * Example:
 * ```json
 * {
 *   "type": "setFormula",
 *   "params": {
 *     "sheet": "sales",
 *     "cell": "D2",
 *     "formula": "=C2-B2"
 *   }
 * }
 * ```
 */
export interface SetFormulaOperation extends BaseOperation {
  type: 'setFormula';
  params: {
    /** Sheet name or ID */
    sheet: string;
    /** Cell reference (e.g., "A1", "B10") */
    cell: string;
    /** Formula string (with or without leading =) */
    formula: string;
  };
}

// ============================================================================
// Formatting Operations
// ============================================================================

/**
 * Format specification for cells or ranges
 */
export interface FormatSpec {
  /** Cell styling (bold, colors, etc.) */
  style?: CellStyle;
  /** Number format code */
  numFmt?: string;
  /** Borders (if applying to range) */
  borders?: {
    top?: boolean;
    bottom?: boolean;
    left?: boolean;
    right?: boolean;
    all?: boolean;
  };
}

/**
 * Apply formatting to cells or ranges
 * 
 * Can apply to single cells or ranges (A1:D10).
 * 
 * Example:
 * ```json
 * {
 *   "type": "applyFormat",
 *   "params": {
 *     "sheet": "sales",
 *     "range": "A1:D1",
 *     "format": {
 *       "style": {
 *         "bold": true,
 *         "bgColor": "#f0f0f0"
 *       },
 *       "borders": {
 *         "bottom": true
 *       }
 *     }
 *   }
 * }
 * ```
 */
export interface ApplyFormatOperation extends BaseOperation {
  type: 'applyFormat';
  params: {
    /** Sheet name or ID */
    sheet: string;
    /** Cell reference (A1) or range (A1:D10) */
    range: string;
    /** Format specification */
    format: FormatSpec;
  };
}

/**
 * Merge cells in a range
 * 
 * Merges all cells in the specified range into a single merged cell.
 * The top-left cell's value is preserved.
 * 
 * Example:
 * ```json
 * {
 *   "type": "mergeCells",
 *   "params": {
 *     "sheet": "sales",
 *     "range": "A1:D1"
 *   }
 * }
 * ```
 */
export interface MergeCellsOperation extends BaseOperation {
  type: 'mergeCells';
  params: {
    /** Sheet name or ID */
    sheet: string;
    /** Range to merge (e.g., "A1:D1") */
    range: string;
  };
}

// ============================================================================
// Named Range Operations
// ============================================================================

/**
 * Define a named range
 * 
 * Creates a named range that can be used in formulas.
 * Named ranges make formulas more readable and maintainable.
 * 
 * Example:
 * ```json
 * {
 *   "type": "defineNamedRange",
 *   "params": {
 *     "name": "SalesData",
 *     "sheet": "sales",
 *     "range": "A2:D100",
 *     "scope": "workbook"
 *   }
 * }
 * ```
 * 
 * Then in formulas: `=SUM(SalesData)` instead of `=SUM(Sales!A2:D100)`
 */
export interface DefineNamedRangeOperation extends BaseOperation {
  type: 'defineNamedRange';
  params: {
    /** Name for the range (e.g., "SalesData", "TotalRevenue") */
    name: string;
    /** Sheet name or ID */
    sheet: string;
    /** Range reference (e.g., "A2:D100") */
    range: string;
    /** Scope: "workbook" (accessible from all sheets) or "sheet" (local to sheet) */
    scope?: 'workbook' | 'sheet';
  };
}

// ============================================================================
// Computation Operations
// ============================================================================

/**
 * Trigger formula computation
 * 
 * **CRITICAL**: This operation MUST be called after setting any formulas.
 * It hydrates HyperFormula, computes all formulas, and patches the workbook cache.
 * 
 * Example:
 * ```json
 * {
 *   "type": "compute",
 *   "params": {}
 * }
 * ```
 */
export interface ComputeOperation extends BaseOperation {
  type: 'compute';
  params: {
    /** Force full recomputation (default: false, uses incremental) */
    force?: boolean;
  };
}

// ============================================================================
// Import/Export Operations
// ============================================================================

/**
 * Import Excel file
 * 
 * Parses an uploaded .xlsx file into workbook format.
 * Uses SheetJS (xlsx) library.
 * 
 * Example:
 * ```json
 * {
 *   "type": "importXLSX",
 *   "params": {
 *     "fileData": "<base64 or ArrayBuffer>",
 *     "fileName": "budget.xlsx"
 *   }
 * }
 * ```
 */
export interface ImportXLSXOperation extends BaseOperation {
  type: 'importXLSX';
  params: {
    /** File data (base64 string or ArrayBuffer) */
    fileData: string | ArrayBuffer;
    /** Optional filename for metadata */
    fileName?: string;
  };
}

/**
 * Export workbook to Excel file
 * 
 * Generates a .xlsx file from the current workbook.
 * Uses ExcelJS library for high-fidelity export.
 * 
 * Example:
 * ```json
 * {
 *   "type": "exportXLSX",
 *   "params": {
 *     "fileName": "Q1_Budget_2025.xlsx"
 *   }
 * }
 * ```
 */
export interface ExportXLSXOperation extends BaseOperation {
  type: 'exportXLSX';
  params: {
    /** Output filename (default: "workbook.xlsx") */
    fileName?: string;
  };
}

// ============================================================================
// Union Type & Type Guards
// ============================================================================

/**
 * Union type of all possible workbook operations
 * 
 * This is the primary type used by WorkbookOperationExecutor.
 */
export type WorkbookOperation =
  | CreateWorkbookOperation
  | AddSheetOperation
  | RemoveSheetOperation
  | RenameSheetOperation
  | SetCellsOperation
  | SetFormulaOperation
  | ApplyFormatOperation
  | MergeCellsOperation
  | DefineNamedRangeOperation
  | ComputeOperation
  | ImportXLSXOperation
  | ExportXLSXOperation;

/**
 * Type guard to check if an operation is CreateWorkbookOperation
 */
export function isCreateWorkbookOperation(op: WorkbookOperation): op is CreateWorkbookOperation {
  return op.type === 'createWorkbook';
}

/**
 * Type guard to check if an operation is AddSheetOperation
 */
export function isAddSheetOperation(op: WorkbookOperation): op is AddSheetOperation {
  return op.type === 'addSheet';
}

/**
 * Type guard to check if an operation is RemoveSheetOperation
 */
export function isRemoveSheetOperation(op: WorkbookOperation): op is RemoveSheetOperation {
  return op.type === 'removeSheet';
}

/**
 * Type guard to check if an operation is RenameSheetOperation
 */
export function isRenameSheetOperation(op: WorkbookOperation): op is RenameSheetOperation {
  return op.type === 'renameSheet';
}

/**
 * Type guard to check if an operation is SetCellsOperation
 */
export function isSetCellsOperation(op: WorkbookOperation): op is SetCellsOperation {
  return op.type === 'setCells';
}

/**
 * Type guard to check if an operation is SetFormulaOperation
 */
export function isSetFormulaOperation(op: WorkbookOperation): op is SetFormulaOperation {
  return op.type === 'setFormula';
}

/**
 * Type guard to check if an operation is ApplyFormatOperation
 */
export function isApplyFormatOperation(op: WorkbookOperation): op is ApplyFormatOperation {
  return op.type === 'applyFormat';
}

/**
 * Type guard to check if an operation is MergeCellsOperation
 */
export function isMergeCellsOperation(op: WorkbookOperation): op is MergeCellsOperation {
  return op.type === 'mergeCells';
}

/**
 * Type guard to check if an operation is DefineNamedRangeOperation
 */
export function isDefineNamedRangeOperation(op: WorkbookOperation): op is DefineNamedRangeOperation {
  return op.type === 'defineNamedRange';
}

/**
 * Type guard to check if an operation is ComputeOperation
 */
export function isComputeOperation(op: WorkbookOperation): op is ComputeOperation {
  return op.type === 'compute';
}

/**
 * Type guard to check if an operation is ImportXLSXOperation
 */
export function isImportXLSXOperation(op: WorkbookOperation): op is ImportXLSXOperation {
  return op.type === 'importXLSX';
}

/**
 * Type guard to check if an operation is ExportXLSXOperation
 */
export function isExportXLSXOperation(op: WorkbookOperation): op is ExportXLSXOperation {
  return op.type === 'exportXLSX';
}

// ============================================================================
// AI Response Types
// ============================================================================

/**
 * AI-generated response containing workbook operations
 * 
 * This is the structure returned by the AI when generating operations.
 */
export interface AIOperationResponse {
  /** Descriptive intent name (e.g., "q1_budget_tracker") */
  intent: string;
  /** List of operations to execute */
  operations: WorkbookOperation[];
  /** Human-readable explanation of what was created */
  explanation: string;
  /** Confidence score (0.0 to 1.0) */
  confidence: number;
}

/**
 * Result of executing operations
 */
export interface OperationExecutionResult {
  /** Whether execution succeeded */
  success: boolean;
  /** The resulting workbook (if successful) */
  workbook?: any; // WorkbookJSON type from workbook/types.ts
  /** List of errors (if any) */
  errors: OperationError[];
  /** List of warnings (non-fatal issues) */
  warnings?: string[];
  /** Number of operations executed successfully */
  operationsExecuted: number;
  /** Total number of operations attempted */
  operationsTotal: number;
}

/**
 * Error encountered during operation execution
 */
export interface OperationError {
  /** Index of the operation that failed (0-based) */
  operationIndex: number;
  /** The operation that failed */
  operation: WorkbookOperation;
  /** Error message */
  message: string;
  /** Error code (for programmatic handling) */
  code?: string;
}

// ============================================================================
// Validation Types
// ============================================================================

/**
 * Validation result for a workbook
 */
export interface ValidationResult {
  /** Whether workbook is valid */
  valid: boolean;
  /** List of errors (critical issues) */
  errors: ValidationIssue[];
  /** List of warnings (non-critical issues) */
  warnings: ValidationIssue[];
  /** List of suggestions (improvements) */
  suggestions: ValidationIssue[];
}

/**
 * A single validation issue
 */
export interface ValidationIssue {
  /** Issue severity */
  severity: 'error' | 'warning' | 'suggestion';
  /** Issue type/code */
  code: string;
  /** Human-readable message */
  message: string;
  /** Location (e.g., "Sheet1!A1", "Sheet2") */
  location?: string;
  /** Sheet name/id */
  sheet?: string;
  /** Cell reference */
  cell?: string;
  /** Suggested fix */
  suggestion?: string;
}

// ============================================================================
// Utility Types
// ============================================================================

/**
 * Extract operation type from WorkbookOperation union
 */
export type OperationType = WorkbookOperation['type'];

/**
 * Extract params type for a specific operation type
 */
export type OperationParams<T extends OperationType> = Extract<WorkbookOperation, { type: T }>['params'];

/**
 * Helper to create a typed operation
 */
export function createOperation<T extends OperationType>(
  type: T,
  params: OperationParams<T>
): Extract<WorkbookOperation, { type: T }> {
  return { type, params } as Extract<WorkbookOperation, { type: T }>;
}

/**
 * Validate operation has required parameters
 */
export function validateOperation(op: WorkbookOperation): ValidationResult {
  const errors: ValidationIssue[] = [];
  
  // Validate based on operation type
  switch (op.type) {
    case 'createWorkbook':
      if (!op.params.name || op.params.name.trim() === '') {
        errors.push({
          severity: 'error',
          code: 'MISSING_WORKBOOK_NAME',
          message: 'Workbook name is required',
        });
      }
      break;
      
    case 'addSheet':
      if (!op.params.name || op.params.name.trim() === '') {
        errors.push({
          severity: 'error',
          code: 'MISSING_SHEET_NAME',
          message: 'Sheet name is required',
        });
      }
      break;
      
    case 'setCells':
      if (!op.params.sheet || op.params.sheet.trim() === '') {
        errors.push({
          severity: 'error',
          code: 'MISSING_SHEET_REFERENCE',
          message: 'Sheet reference is required for setCells',
        });
      }
      if (!op.params.cells || Object.keys(op.params.cells).length === 0) {
        errors.push({
          severity: 'error',
          code: 'EMPTY_CELLS_OBJECT',
          message: 'At least one cell must be specified',
        });
      }
      break;
      
    case 'setFormula':
      if (!op.params.sheet || op.params.sheet.trim() === '') {
        errors.push({
          severity: 'error',
          code: 'MISSING_SHEET_REFERENCE',
          message: 'Sheet reference is required for setFormula',
        });
      }
      if (!op.params.cell || op.params.cell.trim() === '') {
        errors.push({
          severity: 'error',
          code: 'MISSING_CELL_REFERENCE',
          message: 'Cell reference is required for setFormula',
        });
      }
      if (!op.params.formula || op.params.formula.trim() === '') {
        errors.push({
          severity: 'error',
          code: 'MISSING_FORMULA',
          message: 'Formula is required for setFormula',
        });
      }
      break;
  }
  
  return {
    valid: errors.length === 0,
    errors,
    warnings: [],
    suggestions: [],
  };
}
