This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.env.example
.github/copilot-instructions.md
.github/instructions/1.Use powershell commands prefered.instructions.md
.github/instructions/Dont spam documentation for every task and documentations shd go to docs folder.instructions.md
.gitignore
client/.gitignore
client/eslint.config.js
client/index.html
client/JSON_WORKBOOK.md
client/package.json
client/postcss.config.js
client/public/sqlite/README.txt
client/public/sqlite/sqlite3-opfs-async-proxy.js
client/public/sqlite/sqlite3-worker1-promiser.js
client/public/sqlite/sqlite3.wasm
client/public/vite.svg
client/README.md
client/src/App.tsx
client/src/components/canvas/CanvasRenderer.tsx
client/src/components/canvas/CellFormattingExample.tsx
client/src/components/canvas/ColorPicker.tsx
client/src/components/canvas/FormatToolbar.tsx
client/src/components/canvas/FormulaBar.tsx
client/src/components/canvas/index.ts
client/src/components/canvas/StyleToolbar.tsx
client/src/components/chat/ChatInterface.tsx
client/src/components/chat/index.ts
client/src/components/layout/Header.tsx
client/src/components/layout/index.ts
client/src/components/layout/MainLayout.tsx
client/src/components/layout/SettingsDialog.tsx
client/src/components/test/index.ts
client/src/components/test/RoundTripTestPage.tsx
client/src/components/ui/Button.tsx
client/src/components/ui/Card.tsx
client/src/components/ui/index.ts
client/src/components/ui/Input.tsx
client/src/index.css
client/src/lib/ai/aiService.ts
client/src/lib/ai/openrouter.ts
client/src/lib/db/index.ts
client/src/lib/db/jsonWorkbook.ts
client/src/lib/types.ts
client/src/lib/utils.ts
client/src/lib/workbook/adapters/exceljs.ts
client/src/lib/workbook/adapters/sheetjs.ts
client/src/lib/workbook/api-example.ts
client/src/lib/workbook/API.md
client/src/lib/workbook/api.ts
client/src/lib/workbook/converters.ts
client/src/lib/workbook/demo.ts
client/src/lib/workbook/exceljs-adapter.test.ts
client/src/lib/workbook/hyperformula.test.ts
client/src/lib/workbook/hyperformula.ts
client/src/lib/workbook/index.ts
client/src/lib/workbook/MIGRATION.md
client/src/lib/workbook/operations.test.ts
client/src/lib/workbook/operations.ts
client/src/lib/workbook/README.md
client/src/lib/workbook/roundtrip.test.ts
client/src/lib/workbook/run-roundtrip-test.js
client/src/lib/workbook/samples/simple.json
client/src/lib/workbook/schema.json
client/src/lib/workbook/sheet-metadata.test.ts
client/src/lib/workbook/test-runner.ts
client/src/lib/workbook/test.ts
client/src/lib/workbook/TYPES_CHANGELOG.md
client/src/lib/workbook/types.ts
client/src/lib/workbook/undo.ts
client/src/lib/workbook/useWorkbook.ts
client/src/lib/workbook/utils.ts
client/src/lib/workbook/validator.test.ts
client/src/lib/workbook/validator.ts
client/src/lib/workbook/workbook-properties.test.ts
client/src/main.tsx
client/src/README.md
client/src/vite-env.d.ts
client/tailwind.config.js
client/tsconfig.app.json
client/tsconfig.json
client/tsconfig.node.json
client/UI_CHECKLIST.md
client/UI.md
client/ui/ThemeProvider.tsx
client/ui/tokens.json
client/vite.config.ts
mcp.json

================================================================
Files
================================================================

================
File: .env.example
================
# ==============================================
# NEXCELL ENVIRONMENT VARIABLES - EXAMPLE FILE
# ==============================================
# Copy this file to .env.local and fill in your actual values

# Server Configuration
NODE_ENV=development
PORT=3001
LOG_LEVEL=info

# CORS Configuration
CORS_ORIGIN=http://localhost:5173

# ==============================================
# DATABASE
# ==============================================
# Neon PostgreSQL connection string
DATABASE_URL=postgresql://user:password@host/database?sslmode=require

# ==============================================
# AUTHENTICATION - Clerk
# ==============================================
CLERK_PUBLISHABLE_KEY=pk_test_your_publishable_key_here
CLERK_SECRET_KEY=sk_test_your_secret_key_here

# ==============================================
# AI SERVICES
# ==============================================
# OpenAI (Primary)
OPENAI_API_KEY=sk-your_openai_key_here

# Anthropic Claude (Fallback)
ANTHROPIC_API_KEY=sk-ant-your_anthropic_key_here

# OpenRouter (Alternative AI Gateway)
OPENROUTER_API_KEY=sk-or-v1-your_openrouter_key_here
OPENROUTER_MODEL=anthropic/claude-3.5-sonnet
OPENROUTER_MAX_TOKENS=4096

# ==============================================
# GOOGLE SHEETS INTEGRATION (Future)
# ==============================================
GOOGLE_SHEETS_CLIENT_ID=your_client_id_here
GOOGLE_SHEETS_CLIENT_SECRET=your_client_secret_here
GOOGLE_SHEETS_REDIRECT_URI=http://localhost:3001/api/auth/google/callback

# ==============================================
# STRIPE PAYMENT (Future)
# ==============================================
STRIPE_SECRET_KEY=sk_test_your_stripe_key_here
STRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret_here
STRIPE_PRICE_ID=price_your_price_id_here

# ==============================================
# MONITORING & LOGGING
# ==============================================
SENTRY_DSN=https://your_sentry_dsn_here
SENTRY_ENVIRONMENT=development

# ==============================================
# RATE LIMITING & PERFORMANCE
# ==============================================
RATE_LIMIT_MAX=100
RATE_LIMIT_WINDOW_MS=60000
MAX_WORKBOOK_SIZE_MB=10
MAX_CELLS_PER_WORKBOOK=500000

# ==============================================
# CREDITS SYSTEM
# ==============================================
DEFAULT_FREE_CREDITS=10
DEFAULT_PAID_CREDITS=50
COST_PER_1K_TOKENS=0.03

================
File: .github/copilot-instructions.md
================
<!-- Auto-generated todo section -->
<!-- Dont generate summary documentation please -->
<!-- Prefer Powershell Commands -->

================
File: .github/instructions/1.Use powershell commands prefered.instructions.md
================
---
applyTo: '**'
---
Provide project context and coding guidelines that AI should follow when generating code, answering questions, or reviewing changes.

================
File: .github/instructions/Dont spam documentation for every task and documentations shd go to docs folder.instructions.md
================
---
applyTo: '**'
---
Provide project context and coding guidelines that AI should follow when generating code, answering questions, or reviewing changes.

================
File: client/.gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: client/eslint.config.js
================
export default defineConfig([
globalIgnores(['dist']),

================
File: client/index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nexcell - AI Spreadsheet Assistant</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: client/JSON_WORKBOOK.md
================
# JSON Workbook Format

Nexcell uses a JSON-based workbook format that enables AI to easily add and modify formulas through chat instructions.

## Workbook Structure

```json
{
  "version": "1.0.0",
  "id": "unique-workbook-id",
  "name": "My Workbook",
  "created": "2024-01-01T00:00:00.000Z",
  "modified": "2024-01-01T00:00:00.000Z",
  "sheets": [
    {
      "id": "unique-sheet-id",
      "name": "Sheet1",
      "position": 0,
      "cells": {
        "R0C0": {
          "value": "Hello",
          "formatting": {}
        },
        "R0C1": {
          "formula": "=A1&\" World\"",
          "formatting": {}
        },
        "R1C0": {
          "value": 100
        },
        "R1C1": {
          "formula": "=A2*2"
        }
      }
    }
  ]
}
```

## Cell Storage Format

Cells are stored in a **sparse format** using keys like `"R0C0"` (Row 0, Column 0):
- Only non-empty cells are stored
- Empty cells are omitted to save space
- Cell references use 0-based indexing

### Cell Object

```typescript
{
  value?: string | number | null;    // Direct value (no formula)
  formula?: string;                  // Formula starting with '='
  formatting?: {                     // Optional formatting
    bold?: boolean;
    italic?: boolean;
    underline?: boolean;
    color?: string;
    backgroundColor?: string;
  }
}
```

## AI Chat Commands

You can use natural language to modify the workbook. The AI understands the following command patterns:

### Set Cell Value

Set a cell to a specific value:

```
Set A1 to 100
Set cell B2 = Hello World
Set C5 to 3.14
```

### Add Formula

Add a formula to a cell:

```
Add formula =A1*2 to B1
Add formula =SUM(A1:A10) to A11
Set C1 = =B1+B2
```

### Create Sum Formula

Quick way to create sum formulas:

```
Create sum in D10 for range A1:A9
Add sum formula in B5 for A1:A4
```

### Fill Range

Fill a range of cells with the same value:

```
Fill A1:A10 with 0
Fill B2:D5 with Hello
```

### Clear Cells

Clear cell contents:

```
Clear cell A1
Clear B5
Clear range A1:C10
Clear C1 to E5
```

## Example Usage

1. **Create a simple calculation:**
   ```
   Set A1 to 10
   Set A2 to 20
   Add formula =A1+A2 to A3
   ```

2. **Build a sum column:**
   ```
   Fill A1:A10 with 5
   Create sum in A11 for range A1:A10
   ```

3. **Clear and reset:**
   ```
   Clear range A1:A10
   Set A1 to New Value
   ```

## Export and Import

### Export Workbook

Click the **Export** button in the header to download your workbook as a JSON file. This file contains:
- All cell values and formulas
- Sheet structure
- Cell formatting (when added)
- Metadata (created/modified dates)

### Import Workbook

To import a JSON workbook:
1. Ensure it follows the correct format (see structure above)
2. Use the import functionality (to be implemented)
3. The workbook will be validated before loading

## Benefits

- **AI-Friendly**: Natural language commands for modifications
- **Version Control**: JSON format works well with Git
- **Portable**: Easy to share and backup
- **Sparse Storage**: Only non-empty cells are stored
- **Human-Readable**: Can manually edit JSON if needed

## Formula Support

Formulas start with `=` and can include:
- Basic arithmetic: `=A1+B1`, `=C1*2`
- Cell references: `=A1`, `=B2:B10`
- Functions: `=SUM(A1:A10)`, `=AVERAGE(B1:B5)`
- Mixed expressions: `=(A1+A2)*B1`

## Future Enhancements

- Import JSON workbooks
- More AI commands (copy, move, format)
- Advanced formula functions
- Multi-sheet operations
- Cell validation and constraints

================
File: client/package.json
================
{
  "name": "nexcell-client",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "description": "Nexcell - AI-powered spreadsheet assistant with Vercel-inspired design",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "type-check": "tsc --noEmit",
    "validate": "node -e \"import('./src/lib/workbook/validator.ts').then(m => m.runValidatorCLI())\"",
    "export-check": "echo 'Export validation - TODO: implement'"
  },
  "dependencies": {
    "@clerk/clerk-react": "^5.51.0",
    "@sqlite.org/sqlite-wasm": "^3.50.4-build1",
    "@tanstack/react-query": "^5.90.3",
    "@tanstack/react-virtual": "^3.13.12",
    "ajv": "^8.17.1",
    "autoprefixer": "^10.4.21",
    "clsx": "^2.1.1",
    "exceljs": "^4.4.0",
    "hyperformula": "^3.1.0",
    "lucide-react": "^0.545.0",
    "postcss": "^8.5.6",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "react-router-dom": "^7.9.4",
    "tailwind-merge": "^3.3.1",
    "tailwindcss": "^4.1.14",
    "xlsx": "^0.18.5",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@tailwindcss/postcss": "^4.1.14",
    "@types/node": "^24.6.0",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-react": "^5.0.4",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.22",
    "globals": "^16.4.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.45.0",
    "vite": "^7.1.7"
  }
}

================
File: client/postcss.config.js
================


================
File: client/public/sqlite/README.txt
================
SQLite WASM assets

Files in this folder are served by Vite so the browser can load:
- sqlite3.wasm
- sqlite3-opfs-async-proxy.js
- sqlite3-worker1-promiser.js

They are copied from @sqlite.org/sqlite-wasm package.

================
File: client/public/sqlite/sqlite3-opfs-async-proxy.js
================
/*
  2022-09-16

  The author disclaims copyright to this source code.  In place of a
  legal notice, here is a blessing:

  *   May you do good and not evil.
  *   May you find forgiveness for yourself and forgive others.
  *   May you share freely, never taking more than you give.

  ***********************************************************************

  A Worker which manages asynchronous OPFS handles on behalf of a
  synchronous API which controls it via a combination of Worker
  messages, SharedArrayBuffer, and Atomics. It is the asynchronous
  counterpart of the API defined in sqlite3-vfs-opfs.js.

  Highly indebted to:

  https://github.com/rhashimoto/wa-sqlite/blob/master/src/examples/OriginPrivateFileSystemVFS.js

  for demonstrating how to use the OPFS APIs.

  This file is to be loaded as a Worker. It does not have any direct
  access to the sqlite3 JS/WASM bits, so any bits which it needs (most
  notably SQLITE_xxx integer codes) have to be imported into it via an
  initialization process.

  This file represents an implementation detail of a larger piece of
  code, and not a public interface. Its details may change at any time
  and are not intended to be used by any client-level code.

  2022-11-27: Chrome v108 changes some async methods to synchronous, as
  documented at:

  https://developer.chrome.com/blog/sync-methods-for-accesshandles/

  Firefox v111 and Safari 16.4, both released in March 2023, also
  include this.

  We cannot change to the sync forms at this point without breaking
  clients who use Chrome v104-ish or higher. truncate(), getSize(),
  flush(), and close() are now (as of v108) synchronous. Calling them
  with an "await", as we have to for the async forms, is still legal
  with the sync forms but is superfluous. Calling the async forms with
  theFunc().then(...) is not compatible with the change to
  synchronous, but we do do not use those APIs that way. i.e. we don't
  _need_ to change anything for this, but at some point (after Chrome
  versions (approximately) 104-107 are extinct) should change our
  usage of those methods to remove the "await".
*/
⋮----
const wPost = (type, ...args) => postMessage({ type, payload: args });
⋮----
throw new Error(args.join(' '));
⋮----
toss(
⋮----
toss('This API requires navigator.storage.getDirectory.');
⋮----
const state = Object.create(null);
⋮----
0: console.error.bind(console),
1: console.warn.bind(console),
2: console.log.bind(console),
⋮----
const logImpl = (level, ...args) => {
⋮----
const log = (...args) => logImpl(2, ...args);
const warn = (...args) => logImpl(1, ...args);
const error = (...args) => logImpl(0, ...args);
⋮----
const __openFiles = Object.create(null);
⋮----
const __implicitLocks = new Set();
⋮----
const p = new URL(filename, 'file://irrelevant').pathname;
return splitIt ? p.split('/').filter((v) => !!v) : p;
⋮----
const path = getResolvedPath(absFilename, true);
const filename = path.pop();
⋮----
dh = await dh.getDirectoryHandle(dirName, { create: !!createDirs });
⋮----
const closeSyncHandle = async (fh) => {
⋮----
log('Closing sync handle for', fh.filenameAbs);
⋮----
__implicitLocks.delete(fh.fid);
return h.close();
⋮----
const closeSyncHandleNoThrow = async (fh) => {
⋮----
await closeSyncHandle(fh);
⋮----
warn('closeSyncHandleNoThrow() ignoring:', e, fh);
⋮----
const releaseImplicitLocks = async () => {
⋮----
await closeSyncHandleNoThrow(fh);
log('Auto-unlocked', fid, fh.filenameAbs);
⋮----
const releaseImplicitLock = async (fh) => {
if (fh.releaseImplicitLocks && __implicitLocks.has(fh.fid)) {
return closeSyncHandleNoThrow(fh);
⋮----
class GetSyncHandleError extends Error {
⋮----
[...msg, ': ' + errorObject.name + ':', errorObject.message].join(' '),
⋮----
GetSyncHandleError.convertRc = (e, rc) => {
⋮----
0 === e.cause.message.indexOf('Access Handles cannot'))
⋮----
const getSyncHandle = async (fh, opName) => {
⋮----
const t = performance.now();
log('Acquiring sync handle for', fh.filenameAbs);
⋮----
fh.syncHandle = await fh.fileHandle.createSyncAccessHandle();
⋮----
throw new GetSyncHandleError(
⋮----
warn(
⋮----
Atomics.wait(state.sabOPView, state.opIds.retry, 0, ms);
⋮----
log(
⋮----
performance.now() - t,
⋮----
__implicitLocks.add(fh.fid);
⋮----
const storeAndNotify = (opName, value) => {
log(opName + '() => notify(', value, ')');
Atomics.store(state.sabOPView, state.opIds.rc, value);
Atomics.notify(state.sabOPView, state.opIds.rc);
⋮----
if (fh.readOnly) toss(opName + '(): File is read-only: ' + fh.filenameAbs);
⋮----
storeAndNotify('opfs-async-shutdown', 0);
⋮----
mkdir: async (dirname) => {
⋮----
await getDirForFilename(dirname + '/filepart', true);
⋮----
state.s11n.storeException(2, e);
⋮----
storeAndNotify('mkdir', rc);
⋮----
xAccess: async (filename) => {
⋮----
const [dh, fn] = await getDirForFilename(filename);
await dh.getFileHandle(fn);
⋮----
storeAndNotify('xAccess', rc);
⋮----
__implicitLocks.delete(fid);
⋮----
await fh.dirHandle.removeEntry(fh.filenamePart);
⋮----
warn('Ignoring dirHandle.removeEntry() failure of', fh, e);
⋮----
state.s11n.serialize();
⋮----
storeAndNotify(opName, rc);
⋮----
const rc = await vfsAsyncImpls.xDeleteNoWait(...args);
storeAndNotify('xDelete', rc);
⋮----
const [hDir, filenamePart] = await getDirForFilename(filename, false);
⋮----
await hDir.removeEntry(filenamePart, { recursive });
⋮----
filename = getResolvedPath(filename, true);
filename.pop();
filename = filename.join('/');
⋮----
const sz = await (await getSyncHandle(fh, 'xFileSize')).getSize();
state.s11n.serialize(Number(sz));
⋮----
state.s11n.storeException(1, e);
rc = GetSyncHandleError.convertRc(e, state.sq3Codes.SQLITE_IOERR);
⋮----
await releaseImplicitLock(fh);
storeAndNotify('xFileSize', rc);
⋮----
await getSyncHandle(fh, 'xLock');
⋮----
rc = GetSyncHandleError.convertRc(
⋮----
storeAndNotify('xLock', rc);
⋮----
[hDir, filenamePart] = await getDirForFilename(filename, !!create);
⋮----
storeAndNotify(opName, state.sq3Codes.SQLITE_NOTFOUND);
⋮----
await hDir.removeEntry(filenamePart);
⋮----
const hFile = await hDir.getFileHandle(filenamePart, { create });
const fh = Object.assign(Object.create(null), {
⋮----
storeAndNotify(opName, 0);
⋮----
error(opName, e);
⋮----
storeAndNotify(opName, state.sq3Codes.SQLITE_IOERR);
⋮----
nRead = (await getSyncHandle(fh, 'xRead')).read(
fh.sabView.subarray(0, n),
{ at: Number(offset64) },
⋮----
fh.sabView.fill(0, nRead, n);
⋮----
error('xRead() failed', e, fh);
⋮----
rc = GetSyncHandleError.convertRc(e, state.sq3Codes.SQLITE_IOERR_READ);
⋮----
storeAndNotify('xRead', rc);
⋮----
await fh.syncHandle.flush();
⋮----
storeAndNotify('xSync', rc);
⋮----
affirmNotRO('xTruncate', fh);
await (await getSyncHandle(fh, 'xTruncate')).truncate(size);
⋮----
error('xTruncate():', e, fh);
⋮----
storeAndNotify('xTruncate', rc);
⋮----
storeAndNotify('xUnlock', rc);
⋮----
affirmNotRO('xWrite', fh);
⋮----
(await getSyncHandle(fh, 'xWrite')).write(fh.sabView.subarray(0, n), {
at: Number(offset64),
⋮----
error('xWrite():', e, fh);
⋮----
rc = GetSyncHandleError.convertRc(e, state.sq3Codes.SQLITE_IOERR_WRITE);
⋮----
storeAndNotify('xWrite', rc);
⋮----
const initS11n = () => {
⋮----
const textDecoder = new TextDecoder(),
textEncoder = new TextEncoder('utf-8'),
viewU8 = new Uint8Array(
⋮----
viewDV = new DataView(
⋮----
state.s11n = Object.create(null);
const TypeIds = Object.create(null);
⋮----
const getTypeId = (v) =>
⋮----
toss('Maintenance required: this value type cannot be serialized.', v);
const getTypeIdById = (tid) => {
⋮----
toss('Invalid type ID:', tid);
⋮----
typeIds.push(getTypeIdById(viewU8[offset]));
⋮----
n = viewDV.getInt32(offset, state.littleEndian);
⋮----
v = textDecoder.decode(viewU8.slice(offset, offset + n));
⋮----
rc.push(v);
⋮----
typeIds.push(getTypeId(args[i]));
⋮----
const s = textEncoder.encode(args[i]);
viewDV.setInt32(offset, s.byteLength, state.littleEndian);
⋮----
viewU8.set(s, offset);
⋮----
state.s11n.serialize([e.name, ': ', e.message].join(''));
⋮----
const opHandlers = Object.create(null);
for (let k of Object.keys(state.opIds)) {
⋮----
const o = Object.create(null);
⋮----
Atomics.wait(
⋮----
await releaseImplicitLocks();
⋮----
const opId = Atomics.load(state.sabOPView, state.opIds.whichOp);
Atomics.store(state.sabOPView, state.opIds.whichOp, 0);
⋮----
opHandlers[opId] ?? toss('No waitLoop handler for whichOp #', opId);
const args = state.s11n.deserialize(true) || [];
⋮----
if (hnd.f) await hnd.f(...args);
else error('Missing callback for opId', opId);
⋮----
error('in waitLoop():', e);
⋮----
.getDirectory()
.then(function (d) {
⋮----
state.sabOPView = new Int32Array(state.sabOP);
state.sabFileBufView = new Uint8Array(
⋮----
state.sabS11nView = new Uint8Array(
⋮----
Object.keys(vfsAsyncImpls).forEach((k) => {
if (!Number.isFinite(state.opIds[k])) {
toss('Maintenance required: missing state.opIds[', k, ']');
⋮----
initS11n();
log('init state', state);
wPost('opfs-async-inited');
waitLoop();
⋮----
wPost('opfs-async-loaded');
⋮----
.catch((e) => error('error initializing OPFS asyncer:', e));
⋮----
wPost(
⋮----
wPost('opfs-unavailable', 'Missing required OPFS APIs.');
⋮----
installAsyncProxy();

================
File: client/public/sqlite/sqlite3-worker1-promiser.js
================
/*
  2022-08-24

  The author disclaims copyright to this source code.  In place of a
  legal notice, here is a blessing:

  *   May you do good and not evil.
  *   May you find forgiveness for yourself and forgive others.
  *   May you share freely, never taking more than you give.

  ***********************************************************************

  This file implements a Promise-based proxy for the sqlite3 Worker
  API #1. It is intended to be included either from the main thread or
  a Worker, but only if (A) the environment supports nested Workers
  and (B) it's _not_ a Worker which loads the sqlite3 WASM/JS
  module. This file's features will load that module and provide a
  slightly simpler client-side interface than the slightly-lower-level
  Worker API does.

  This script necessarily exposes one global symbol, but clients may
  freely `delete` that symbol after calling it.
*/
⋮----
config = Object.assign(Object.create(null), callee.defaultConfig);
⋮----
config = Object.assign(Object.create(null), callee.defaultConfig, config);
⋮----
const handlerMap = Object.create(null);
⋮----
const idTypeMap = config.generateMessageId ? undefined : Object.create(null);
⋮----
const toss = (...args) => {
throw new Error(args.join(' '));
⋮----
if ('function' === typeof config.worker) config.worker = config.worker();
⋮----
debug('worker1.onmessage', ev);
⋮----
if (config.onready) config.onready(promiserFunc);
⋮----
msgHandler.onrow(ev);
⋮----
if (config.onunhandled) config.onunhandled(arguments[0]);
else err('sqlite3Worker1Promiser() unhandled worker message:', ev);
⋮----
msgHandler.reject(ev);
⋮----
msgHandler.resolve(ev);
⋮----
msgHandler.reject(e);
⋮----
msg = Object.create(null);
⋮----
toss('Invalid arguments for sqlite3Worker1Promiser()-created factory.');
⋮----
msg.messageId = genMsgId(msg);
msg.departureTime = performance.now();
const proxy = Object.create(null);
⋮----
toss(
⋮----
let p = new Promise(function (resolve, reject) {
⋮----
debug(
⋮----
config.worker.postMessage(msg);
⋮----
if (rowCallbackId) p = p.finally(() => delete handlerMap[rowCallbackId]);
⋮----
const src = this.currentScript.src.split('/');
src.pop();
theJs = src.join('/') + '/' + theJs;
⋮----
const urlParams = new URL(globalThis.location.href).searchParams;
if (urlParams.has('sqlite3.dir')) {
theJs = urlParams.get('sqlite3.dir') + '/' + theJs;
⋮----
return new Worker(theJs + globalThis.location.search);
}.bind({
⋮----
onerror: (...args) => console.error('worker1 promiser error', ...args),
⋮----
const promiseProxy = Object.create(null);
config = Object.assign(config || Object.create(null), {
⋮----
if (oldFunc) await oldFunc(func);
promiseProxy.resolve(func);
⋮----
promiseProxy.reject(e);
⋮----
const p = new Promise(function (resolve, reject) {
⋮----
this.original(config);

================
File: client/public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: client/README.md
================
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

================
File: client/src/App.tsx
================
import { MainLayout } from './components/layout';
import { RoundTripTestPage } from './components/test';
⋮----
function App()
⋮----
// Check for test mode

================
File: client/src/components/canvas/CanvasRenderer.tsx
================
import { useState, useRef, useEffect } from 'react';
import { useVirtualizer } from '@tanstack/react-virtual';
import { type CellData } from '@/lib/types';
import { cn } from '@/lib/utils';
import { FormulaBar } from './FormulaBar';
⋮----
interface CanvasRendererProps {
  data: CellData[][];
  onCellEdit: (row: number, col: number, value: string) => void;
}
⋮----
export function CanvasRenderer(
⋮----
const handleCellClick = (row: number, col: number) =>
⋮----
const handleCellDoubleClick = (row: number, col: number) =>
⋮----
const commitEdit = () =>
⋮----
const cancelEdit = () =>
⋮----
const handleKeyDown = (e: React.KeyboardEvent) =>
⋮----
// Navigation
⋮----
const getColumnLabel = (index: number): string =>
⋮----
{/* Formula Bar */}
⋮----
onCancel=
⋮----
{/* Canvas */}
⋮----
{/* Column Headers */}
⋮----
{/* Corner cell */}
⋮----
{/* Row Headers and Cells */}
⋮----
{/* Row Header */}
⋮----
{/* Cells */}
⋮----
className=
⋮----
onChange=

================
File: client/src/components/canvas/CellFormattingExample.tsx
================
/**
 * CellFormattingExample Component
 * Example demonstrating how to integrate FormatToolbar with useWorkbook
 */
⋮----
import { useWorkbook } from '@/lib/workbook/useWorkbook';
import { FormulaBar } from './FormulaBar';
import { FormatToolbar } from './FormatToolbar';
import { StyleToolbar } from './StyleToolbar';
import type { Cell, CellStyle } from '@/lib/workbook/types';
⋮----
export function CellFormattingExample()
⋮----
// Note: In a real implementation, you would have state for selectedAddress
// that updates when users click on cells in the canvas
⋮----
// Get current cell
⋮----
/**
   * Handle cell value changes from FormulaBar
   */
const handleCellCommit = (value: string) =>
⋮----
// Formula
⋮----
// Regular value
⋮----
// Auto-detect data type
⋮----
// Preserve existing style and numFmt
⋮----
/**
   * Handle style changes from FormatToolbar
   */
const handleStyleChange = (styleChanges: Partial<CellStyle>) =>
⋮----
/**
   * Handle number format changes from FormatToolbar
   */
const handleNumberFormatChange = (numFmt: string) =>
⋮----
{/* Formula Bar */}
⋮----
// Reset to original value
⋮----
{/* Format Toolbar */}
⋮----
{/* Style Toolbar (additional styling options) */}
⋮----
{/* Main Canvas Area */}
⋮----
{/* 
          CanvasRenderer would go here
          Pass handleCellSelect to handle cell selection events
        */}
⋮----
Style:
⋮----
{/* Status Bar */}

================
File: client/src/components/canvas/ColorPicker.tsx
================
/**
 * ColorPicker Component
 * Simple color picker for cell styling
 */
⋮----
import { useState } from 'react';
⋮----
interface ColorPickerProps {
  value?: string;
  onChange: (color: string) => void;
  label?: string;
}
⋮----
// Common Excel colors
⋮----
const handleColorSelect = (color: string) =>
⋮----
const handleCustomColorChange = (e: React.ChangeEvent<HTMLInputElement>) =>
⋮----
{/* Preset colors grid */}
⋮----
{/* Custom color input */}
⋮----
onChange=
⋮----
{/* Close button */}

================
File: client/src/components/canvas/FormatToolbar.tsx
================
/**
 * FormatToolbar Component
 * Provides formatting controls for cells (styles and number formats)
 */
⋮----
import { useState } from 'react';
import { Button } from '@/components/ui/Button';
import { ColorPicker } from './ColorPicker';
import type { CellStyle } from '@/lib/workbook/types';
⋮----
interface FormatToolbarProps {
  selectedCell?: {
    address: string;
    style?: CellStyle;
    numFmt?: string;
  };
  onStyleChange: (style: Partial<CellStyle>) => void;
  onNumberFormatChange: (numFmt: string) => void;
  disabled?: boolean;
}
⋮----
// Common number formats
⋮----
const toggleBold = () =>
⋮----
const toggleItalic = () =>
⋮----
const toggleUnderline = () =>
⋮----
const toggleStrikethrough = () =>
⋮----
const handleNumFmtSelect = (format: string) =>
⋮----
const handleCustomNumFmt = () =>
⋮----
const handleTextColorChange = (color: string) =>
⋮----
const handleBgColorChange = (color: string) =>
⋮----
{/* Font Styles */}
⋮----
{/* Colors */}
⋮----
{/* Number Format Picker */}
⋮----
{/* Preset formats */}
⋮----
{/* Custom format */}
⋮----
onChange=
⋮----
{/* Info about selected cell */}

================
File: client/src/components/canvas/FormulaBar.tsx
================
import { useState, useEffect } from 'react';
import { cn } from '@/lib/utils';
⋮----
interface FormulaBarProps {
  value: string;
  cellReference: string;
  onCommit: (value: string) => void;
  onCancel: () => void;
  readOnly?: boolean;
}
⋮----
const handleKeyDown = (e: React.KeyboardEvent) =>
⋮----
{/* Cell Reference */}
⋮----
{/* Formula Input */}

================
File: client/src/components/canvas/index.ts
================


================
File: client/src/components/canvas/StyleToolbar.tsx
================
/**
 * StyleToolbar Component
 * Extended formatting toolbar with alignment, font size, and additional style options
 */
⋮----
import { useState } from 'react';
import { Button } from '@/components/ui/Button';
import { ColorPicker } from './ColorPicker';
import type { CellStyle } from '@/lib/workbook/types';
⋮----
interface StyleToolbarProps {
  selectedCell?: {
    address: string;
    style?: CellStyle;
  };
  onStyleChange: (style: Partial<CellStyle>) => void;
  disabled?: boolean;
}
⋮----
const handleAlignmentChange = (
    horizontal?: 'left' | 'center' | 'right',
    vertical?: 'top' | 'middle' | 'bottom'
) =>
⋮----
const handleFontSizeChange = (size: number) =>
⋮----
const handleFontFamilyChange = (family: string) =>
⋮----
const handleTextColorChange = (color: string) =>
⋮----
const handleBgColorChange = (color: string) =>
⋮----
{/* Font Family */}
⋮----
{/* Font Size */}
⋮----
{/* Colors */}
⋮----
{/* Horizontal Alignment */}
⋮----
{/* Vertical Alignment */}

================
File: client/src/components/chat/ChatInterface.tsx
================
import { useRef, useEffect, useState } from 'react';
import { Send } from 'lucide-react';
import { type Message } from '@/lib/types';
import { cn } from '@/lib/utils';
⋮----
interface ChatInterfaceProps {
  messages: Message[];
  onSendMessage: (content: string) => void;
  isLoading?: boolean;
}
⋮----
const handleSubmit = (e: React.FormEvent) =>
⋮----
const handleKeyDown = (e: React.KeyboardEvent) =>
⋮----
const handleInput = (e: React.ChangeEvent<HTMLTextAreaElement>) =>
⋮----
// Auto-resize textarea
⋮----
{/* Chat header */}
⋮----
{/* Messages list */}
⋮----
{/* Input area */}

================
File: client/src/components/chat/index.ts
================


================
File: client/src/components/layout/Header.tsx
================
import { useState } from 'react';
import { Download, Settings } from 'lucide-react';
⋮----
interface HeaderProps {
  workbookName: string;
  onWorkbookNameChange: (name: string) => void;
  onExportJSON?: () => void;
  onOpenSettings?: () => void;
}
⋮----
const handleBlur = () =>
⋮----
const handleKeyDown = (e: React.KeyboardEvent) =>
⋮----
{/* Left section */}
⋮----
onChange=
⋮----
{/* Right section */}

================
File: client/src/components/layout/index.ts
================


================
File: client/src/components/layout/MainLayout.tsx
================
import { useState } from 'react';
import { Header } from './Header';
import { SettingsDialog } from './SettingsDialog';
import { ChatInterface } from '../chat/ChatInterface';
import { CanvasRenderer } from '../canvas/CanvasRenderer';
import { type Message } from '@/lib/types';
import { 
  useWorkbook,
  workbookToCellArray,
  createCellFromInput,
  toAddress,
  // SheetJSAdapter, // For XLSX export (future)
} from '@/lib/workbook';
⋮----
// SheetJSAdapter, // For XLSX export (future)
⋮----
import { parseAICommand, describeAction, EXAMPLE_COMMANDS } from '@/lib/ai/aiService';
import { parseCommandWithAI, convertToWorkbookActions, findNextEmptyRow } from '@/lib/ai/openrouter';
⋮----
// New workbook system
⋮----
// Convert workbook to cell array for rendering
⋮----
// Apply AI actions to workbook
const applyAction = (action: any) =>
⋮----
const address = toAddress(action.row + 1, action.col + 1); // Convert to 1-based
⋮----
const handleSendMessage = async (content: string) =>
⋮----
// Handle help command
⋮----
// Try pattern matching first (fast)
⋮----
// Apply actions using pattern matching
⋮----
// Fall back to AI (OpenRouter) for complex commands
⋮----
// Show thinking message
⋮----
// Get context - include existing data for better AI understanding
⋮----
// Sample some existing data to give AI context
⋮----
// Call AI
⋮----
// Remove thinking message
⋮----
// Convert AI actions to workbook operations
⋮----
// Apply all operations
⋮----
// Delete cell
⋮----
// Success message
⋮----
// AI couldn't understand
⋮----
const handleCellEdit = (row: number, col: number, value: string) =>
⋮----
const address = toAddress(row + 1, col + 1); // Convert 0-based to 1-based
⋮----
const handleExportJSON = () =>
⋮----
// Export as XLSX (ready to use when needed)
// const handleExportXLSX = async () => {
//   const adapter = new SheetJSAdapter();
//   const buffer = await adapter.export(workbook);
//   const blob = new Blob([buffer], {
//     type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
//   });
//   const url = URL.createObjectURL(blob);
//   const a = document.createElement('a');
//   a.href = url;
//   a.download = `${workbookName.replace(/[^a-z0-9]/gi, '_')}.xlsx`;
//   document.body.appendChild(a);
//   a.click();
//   document.body.removeChild(a);
//   URL.revokeObjectURL(url);
// };
⋮----
{/* Chat Panel */}
⋮----
{/* Canvas */}

================
File: client/src/components/layout/SettingsDialog.tsx
================
/**
 * Settings dialog for API keys and configuration
 */
⋮----
import { useState, useEffect } from 'react';
import { X, Key } from 'lucide-react';
⋮----
interface SettingsDialogProps {
  isOpen: boolean;
  onClose: () => void;
}
⋮----
export function SettingsDialog(
⋮----
// Try localStorage first, then fall back to environment variable
⋮----
const handleSave = () =>
⋮----
{/* Header */}
⋮----
{/* Content */}
⋮----
{/* Footer */}

================
File: client/src/components/test/index.ts
================


================
File: client/src/components/test/RoundTripTestPage.tsx
================
/**
 * Round-Trip Test Page
 * Temporary component for testing workbook export/import round-trip
 */
⋮----
import { useState } from 'react';
import { Button } from '../ui/Button';
⋮----
const runTests = async () =>
⋮----
// Dynamically import the test functions
⋮----
// Capture console output
⋮----
// Run SheetJS test
⋮----
// Run ExcelJS test
⋮----
// Summary
⋮----
// Restore console

================
File: client/src/components/ui/Button.tsx
================
import { cn } from '@/lib/utils';
⋮----
export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'ghost' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  isLoading?: boolean;
}
⋮----
className=
⋮----
<svg className="animate-spin -ml-1 mr-2 h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">

================
File: client/src/components/ui/Card.tsx
================
import { cn } from '@/lib/utils';
⋮----
interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
  hover?: boolean;
}
⋮----
className=
⋮----
<div ref=
⋮----
<p ref=

================
File: client/src/components/ui/index.ts
================


================
File: client/src/components/ui/Input.tsx
================
import { cn } from '@/lib/utils';
⋮----
export interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  helperText?: string;
  error?: string;
}
⋮----
className=

================
File: client/src/index.css
================
:root {
⋮----
/* Custom design tokens */
⋮----
/* Custom shadows */
⋮----
/* Custom scrollbar styles */
.scrollbar-thin::-webkit-scrollbar {
⋮----
.scrollbar-thin::-webkit-scrollbar-track {
⋮----
.scrollbar-thin::-webkit-scrollbar-thumb {
⋮----
.scrollbar-thin::-webkit-scrollbar-thumb:hover {
⋮----
/* Base styles */
* {
⋮----
html,
⋮----
/* Focus visible styles */
*:focus-visible {
⋮----
button:focus-visible,

================
File: client/src/lib/ai/aiService.ts
================
/**
 * AI Service for processing chat instructions and generating workbook actions
 */
⋮----
import type { WorkbookAction } from '@/lib/types';
import { parseCellReference } from '@/lib/db/jsonWorkbook';
⋮----
export interface AICommand {
  intent: string;
  parameters: Record<string, any>;
  actions: WorkbookAction[];
}
⋮----
/**
 * Parses user chat message and generates workbook actions
 */
export function parseAICommand(message: string, sheetId: string = 'sheet-1'): AICommand
⋮----
// Pattern: Set cell A1 to [value]
⋮----
// Check if it's a formula (starts with =)
⋮----
// Try to parse as number
⋮----
// Pattern: Add formula [formula] to [cell]
⋮----
// Ensure formula starts with =
⋮----
// Pattern: Clear cell [cell] or Clear [cell]
⋮----
// Pattern: Clear range [start]:[end] or Clear [start] to [end]
⋮----
// Pattern: Create sum formula in [cell] for [range]
⋮----
// Pattern: Fill [range] with [value]
⋮----
// No recognized pattern
⋮----
/**
 * Generates a human-readable description of the action
 */
export function describeAction(action: WorkbookAction): string
⋮----
function formatCell(row: number, col: number): string
⋮----
/**
 * Example commands for user reference
 */

================
File: client/src/lib/ai/openrouter.ts
================
/**
 * OpenRouter AI Integration
 * Uses LLM to parse natural language into structured workbook actions
 */
⋮----
import { parseAddress, toAddress } from '@/lib/workbook';
⋮----
export interface StructuredAction {
  type: 'setCellValue' | 'setCellFormula' | 'fillRange' | 'fillColumn' | 'fillRow' | 'clearRange' | 'insertRow' | 'insertColumn';
  target?: string; // Cell address like "A1" or column like "B" or row like "5"
  value?: string | number | boolean;
  formula?: string;
  range?: { start: string; end: string };
  values?: any[][];
  position?: number;
}
⋮----
target?: string; // Cell address like "A1" or column like "B" or row like "5"
⋮----
export interface AIResponse {
  success: boolean;
  actions: StructuredAction[];
  explanation: string;
  confidence: number;
}
⋮----
/**
 * Send request to OpenRouter API
 */
async function callOpenRouter(prompt: string, apiKey: string): Promise<string>
⋮----
/**
 * Parse user command using OpenRouter AI
 */
export async function parseCommandWithAI(
  command: string,
  apiKey: string,
  context?: {
    lastRow?: number;
    lastCol?: number;
    selectedCell?: string;
    clipboardData?: any[][];
    existingData?: string[];
  }
): Promise<AIResponse>
⋮----
// Add context to prompt
⋮----
// Parse JSON response with better error handling
⋮----
.replace(/^[^{]*/, '') // Remove any text before first {
.replace(/[^}]*$/, '') // Remove any text after last }
⋮----
// Validate the response structure
⋮----
// Validate each action has required fields
⋮----
/**
 * Convert structured actions to workbook operations
 */
export function convertToWorkbookActions(
  structuredActions: StructuredAction[],
  workbookContext: {
    currentSheet: { cells: Record<string, any>; grid?: { rowCount: number; colCount: number } };
  }
): Array<
⋮----
// Replace row references
⋮----
// If we have an array of values, use them
⋮----
// Smart data type detection
⋮----
// Check if it's a date string
⋮----
// String that looks like a number
⋮----
// Fill entire row with single value or formula
⋮----
// Replace column references
⋮----
cell: null, // null means delete
⋮----
/**
 * Convert column letter to number (A=1, B=2, ... Z=26, AA=27, etc.)
 */
function columnLetterToNumber(letter: string): number
⋮----
/**
 * Find next empty row in a sheet
 */
export function findNextEmptyRow(cells: Record<string, any>): number
⋮----
// Skip invalid addresses

================
File: client/src/lib/db/index.ts
================
// JSON Workbook - Comprehensive Excel/Google Sheets compatible format

================
File: client/src/lib/db/jsonWorkbook.ts
================
/**
 * JSON Workbook utilities
 * Comprehensive Excel/Google Sheets compatible workbook operations
 */
⋮----
import type {
  JSONWorkbook,
  JSONSheet,
  JSONCell,
  CellData,
  CellRange,
  CellFormatting,
  MergedCellRange,
  ConditionalFormat,
  DataValidation,
  Chart,
  CellComment,
} from '@/lib/types';
⋮----
/**
 * Creates a blank JSON workbook with comprehensive settings
 */
export function createBlankWorkbook(name: string = 'Untitled Workbook'): JSONWorkbook
⋮----
cells: {}, // Sparse storage - only non-empty cells
⋮----
/**
 * Converts JSON workbook to cell array format for rendering
 */
export function jsonWorkbookToCellArray(
  workbook: JSONWorkbook,
  sheetIndex: number = 0,
  rows: number = 100,
  cols: number = 20
): CellData[][]
⋮----
// Populate cells from sparse JSON storage
⋮----
/**
 * Updates a cell in the JSON workbook
 */
export function updateCell(
  workbook: JSONWorkbook,
  sheetIndex: number,
  row: number,
  col: number,
  update: Partial<JSONCell>
): JSONWorkbook
⋮----
// Merge update with existing cell
⋮----
// If cell is now empty, remove it (sparse storage)
⋮----
/**
 * Sets a formula in a cell
 */
export function setCellFormula(
  workbook: JSONWorkbook,
  sheetIndex: number,
  row: number,
  col: number,
  formula: string
): JSONWorkbook
⋮----
value: null, // Clear value when formula is set
⋮----
/**
 * Sets a value in a cell (clears formula)
 */
export function setCellValue(
  workbook: JSONWorkbook,
  sheetIndex: number,
  row: number,
  col: number,
  value: string | number | null
): JSONWorkbook
⋮----
formula: undefined, // Clear formula when value is set directly
⋮----
/**
 * Clears a range of cells
 */
export function clearRange(
  workbook: JSONWorkbook,
  sheetIndex: number,
  startRow: number,
  startCol: number,
  endRow: number,
  endCol: number
): JSONWorkbook
⋮----
/**
 * Exports workbook to JSON string
 */
export function exportWorkbook(workbook: JSONWorkbook): string
⋮----
/**
 * Imports workbook from JSON string
 */
export function importWorkbook(json: string): JSONWorkbook
⋮----
// Validate basic structure
⋮----
/**
 * Gets a cell from the workbook
 */
export function getCell(
  workbook: JSONWorkbook,
  sheetIndex: number,
  row: number,
  col: number
): JSONCell | null
⋮----
/**
 * Parses a cell reference like "A1" to row/col indices
 */
export function parseCellReference(ref: string):
⋮----
col -= 1; // Convert to 0-indexed
⋮----
const row = parseInt(rowStr, 10) - 1; // Convert to 0-indexed
⋮----
/**
 * Formats row/col indices to cell reference like "A1"
 */
export function formatCellReference(row: number, col: number): string
⋮----
let c = col + 1; // Convert to 1-indexed
⋮----
// ===== Sheet Management =====
⋮----
/**
 * Adds a new sheet to the workbook
 */
export function addSheet(
  workbook: JSONWorkbook,
  name?: string,
  position?: number
): JSONWorkbook
⋮----
// Update positions
⋮----
/**
 * Deletes a sheet from the workbook
 */
export function deleteSheet(workbook: JSONWorkbook, sheetId: string): JSONWorkbook
⋮----
/**
 * Renames a sheet
 */
export function renameSheet(
  workbook: JSONWorkbook,
  sheetId: string,
  newName: string
): JSONWorkbook
⋮----
/**
 * Gets a sheet by ID
 */
export function getSheet(workbook: JSONWorkbook, sheetId: string): JSONSheet | null
⋮----
/**
 * Gets a sheet by index
 */
export function getSheetByIndex(workbook: JSONWorkbook, index: number): JSONSheet | null
⋮----
// ===== Cell Formatting =====
⋮----
/**
 * Applies formatting to a range of cells
 */
export function formatCells(
  workbook: JSONWorkbook,
  sheetId: string,
  ranges: CellRange[],
  formatting: CellFormatting
): JSONWorkbook
⋮----
/**
 * Clears formatting from a range
 */
export function clearFormatting(
  workbook: JSONWorkbook,
  sheetId: string,
  range: CellRange
): JSONWorkbook
⋮----
// ===== Merged Cells =====
⋮----
/**
 * Merges cells in a range
 */
export function mergeCells(
  workbook: JSONWorkbook,
  sheetId: string,
  range: MergedCellRange
): JSONWorkbook
⋮----
/**
 * Unmerges cells in a range
 */
export function unmergeCells(
  workbook: JSONWorkbook,
  sheetId: string,
  range: MergedCellRange
): JSONWorkbook
⋮----
// ===== Row and Column Operations =====
⋮----
/**
 * Sets the height of a row
 */
export function setRowHeight(
  workbook: JSONWorkbook,
  sheetId: string,
  row: number,
  height: number
): JSONWorkbook
⋮----
/**
 * Sets the width of a column
 */
export function setColumnWidth(
  workbook: JSONWorkbook,
  sheetId: string,
  col: number,
  width: number
): JSONWorkbook
⋮----
/**
 * Inserts rows at a position
 */
export function insertRows(
  workbook: JSONWorkbook,
  sheetId: string,
  startRow: number,
  count: number
): JSONWorkbook
⋮----
// Shift existing cells down
⋮----
/**
 * Deletes rows at a position
 */
export function deleteRows(
  workbook: JSONWorkbook,
  sheetId: string,
  startRow: number,
  count: number
): JSONWorkbook
⋮----
// Remove deleted rows and shift remaining cells up
⋮----
// Cells in deleted range are omitted
⋮----
/**
 * Inserts columns at a position
 */
export function insertColumns(
  workbook: JSONWorkbook,
  sheetId: string,
  startCol: number,
  count: number
): JSONWorkbook
⋮----
// Shift existing cells right
⋮----
/**
 * Deletes columns at a position
 */
export function deleteColumns(
  workbook: JSONWorkbook,
  sheetId: string,
  startCol: number,
  count: number
): JSONWorkbook
⋮----
// Remove deleted columns and shift remaining cells left
⋮----
// Cells in deleted range are omitted
⋮----
// ===== Conditional Formatting =====
⋮----
/**
 * Adds a conditional format rule
 */
export function addConditionalFormat(
  workbook: JSONWorkbook,
  sheetId: string,
  format: ConditionalFormat
): JSONWorkbook
⋮----
/**
 * Removes a conditional format rule
 */
export function removeConditionalFormat(
  workbook: JSONWorkbook,
  sheetId: string,
  formatId: string
): JSONWorkbook
⋮----
// ===== Data Validation =====
⋮----
/**
 * Adds a data validation rule
 */
export function addDataValidation(
  workbook: JSONWorkbook,
  sheetId: string,
  validation: DataValidation
): JSONWorkbook
⋮----
// ===== Charts =====
⋮----
/**
 * Adds a chart to the sheet
 */
export function addChart(
  workbook: JSONWorkbook,
  sheetId: string,
  chart: Chart
): JSONWorkbook
⋮----
/**
 * Removes a chart from the sheet
 */
export function removeChart(
  workbook: JSONWorkbook,
  sheetId: string,
  chartId: string
): JSONWorkbook
⋮----
// ===== Comments =====
⋮----
/**
 * Adds a comment to a cell
 */
export function addComment(
  workbook: JSONWorkbook,
  sheetId: string,
  row: number,
  col: number,
  comment: CellComment
): JSONWorkbook
⋮----
/**
 * Removes a comment from a cell
 */
export function removeComment(
  workbook: JSONWorkbook,
  sheetId: string,
  row: number,
  col: number
): JSONWorkbook
⋮----
// ===== Utility Functions =====
⋮----
/**
 * Parses a range reference like "A1:B10" to row/col indices
 */
export function parseRangeReference(ref: string): CellRange | null
⋮----
/**
 * Formats a range to reference format like "A1:B10"
 */
export function formatRangeReference(range: CellRange): string
⋮----
/**
 * Gets all cells in a range
 */
export function getCellsInRange(
  workbook: JSONWorkbook,
  sheetId: string,
  range: CellRange
): Array<
⋮----
/**
 * Copies a range of cells
 */
export function copyRange(
  workbook: JSONWorkbook,
  sheetId: string,
  sourceRange: CellRange,
  targetRow: number,
  targetCol: number
): JSONWorkbook
⋮----
/**
 * Gets workbook statistics
 */
export function getWorkbookStats(workbook: JSONWorkbook):

================
File: client/src/lib/types.ts
================
// Core types for Nexcell - Comprehensive Excel/Google Sheets compatible format
⋮----
export interface Message {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: Date;
  action?: WorkbookAction; // Optional action that modifies workbook
}
⋮----
action?: WorkbookAction; // Optional action that modifies workbook
⋮----
export interface CellData {
  value: string | number | boolean | null;
  formula?: string;
  formatting?: CellFormatting;
  dataType?: CellDataType;
}
⋮----
export type CellDataType = 'string' | 'number' | 'boolean' | 'date' | 'error' | 'formula';
⋮----
export interface CellFormatting {
  // Font styling
  bold?: boolean;
  italic?: boolean;
  underline?: boolean | 'single' | 'double';
  strikethrough?: boolean;
  fontFamily?: string;
  fontSize?: number;
  color?: string;
  
  // Background
  backgroundColor?: string;
  
  // Alignment
  horizontalAlign?: 'left' | 'center' | 'right' | 'justify';
  verticalAlign?: 'top' | 'middle' | 'bottom';
  wrapText?: boolean;
  textRotation?: number; // degrees
  
  // Borders
  borderTop?: BorderStyle;
  borderRight?: BorderStyle;
  borderBottom?: BorderStyle;
  borderLeft?: BorderStyle;
  
  // Number formatting
  numberFormat?: string; // e.g., "0.00", "#,##0", "mm/dd/yyyy"
  
  // Cell protection
  locked?: boolean;
  hidden?: boolean;
}
⋮----
// Font styling
⋮----
// Background
⋮----
// Alignment
⋮----
textRotation?: number; // degrees
⋮----
// Borders
⋮----
// Number formatting
numberFormat?: string; // e.g., "0.00", "#,##0", "mm/dd/yyyy"
⋮----
// Cell protection
⋮----
export interface BorderStyle {
  style?: 'thin' | 'medium' | 'thick' | 'dashed' | 'dotted' | 'double';
  color?: string;
}
⋮----
export interface Viewport {
  scrollTop: number;
  scrollLeft: number;
  width: number;
  height: number;
}
⋮----
export interface WorkbookData {
  id: string;
  name: string;
  cells: CellData[][];
  lastModified: Date;
}
⋮----
export type CellPosition = {
  row: number;
  col: number;
};
⋮----
// ===== Comprehensive JSON Workbook Format =====
// Excel/Google Sheets compatible structure
⋮----
export interface JSONWorkbook {
  version: string;
  id: string;
  name: string;
  author?: string;
  created: string;
  modified: string;
  application?: string; // e.g., "Nexcell", "Excel", "Google Sheets"
  
  // Workbook-level settings
  settings?: WorkbookSettings;
  
  // Named ranges (e.g., "SalesData" = "Sheet1!A1:D10")
  namedRanges?: Record<string, NamedRange>;
  
  // Sheets
  sheets: JSONSheet[];
  
  // Metadata
  metadata?: WorkbookMetadata;
}
⋮----
application?: string; // e.g., "Nexcell", "Excel", "Google Sheets"
⋮----
// Workbook-level settings
⋮----
// Named ranges (e.g., "SalesData" = "Sheet1!A1:D10")
⋮----
// Sheets
⋮----
// Metadata
⋮----
export interface WorkbookSettings {
  calcMode?: 'auto' | 'manual'; // Calculation mode
  calcOnSave?: boolean;
  precision?: number; // Decimal precision
  date1904?: boolean; // Mac Excel date system
  defaultFontFamily?: string;
  defaultFontSize?: number;
}
⋮----
calcMode?: 'auto' | 'manual'; // Calculation mode
⋮----
precision?: number; // Decimal precision
date1904?: boolean; // Mac Excel date system
⋮----
export interface WorkbookMetadata {
  tags?: string[];
  category?: string;
  keywords?: string[];
  description?: string;
  company?: string;
  lastModifiedBy?: string;
}
⋮----
export interface NamedRange {
  name: string;
  reference: string; // e.g., "Sheet1!A1:D10"
  scope?: string; // 'workbook' or sheet ID for sheet-level names
  comment?: string;
}
⋮----
reference: string; // e.g., "Sheet1!A1:D10"
scope?: string; // 'workbook' or sheet ID for sheet-level names
⋮----
export interface JSONSheet {
  id: string;
  name: string;
  position: number;
  visible?: boolean;
  color?: string; // Tab color
  
  // Sheet protection
  protected?: boolean;
  protectionPassword?: string; // Hashed
  
  // Grid settings
  gridlines?: boolean;
  showHeaders?: boolean;
  rightToLeft?: boolean;
  
  // Frozen panes
  frozenRows?: number;
  frozenColumns?: number;
  
  // Zoom level (percentage)
  zoom?: number;
  
  // Default row height and column width
  defaultRowHeight?: number;
  defaultColumnWidth?: number;
  
  // Custom row heights (sparse storage)
  rowHeights?: Record<number, number>;
  
  // Custom column widths (sparse storage)
  columnWidths?: Record<number, number>;
  
  // Hidden rows and columns
  hiddenRows?: number[];
  hiddenColumns?: number[];
  
  // Cells (sparse storage - only non-empty cells)
  cells: Record<string, JSONCell>; // Key format: "R0C0" (row 0, col 0)
  
  // Merged cells
  mergedCells?: MergedCellRange[];
  
  // Conditional formatting rules
  conditionalFormats?: ConditionalFormat[];
  
  // Data validations
  dataValidations?: DataValidation[];
  
  // Filters
  autoFilter?: AutoFilter;
  
  // Charts
  charts?: Chart[];
  
  // Comments/Notes
  comments?: Record<string, CellComment>; // Key format: "R0C0"
  
  // Print settings
  printSettings?: PrintSettings;
}
⋮----
color?: string; // Tab color
⋮----
// Sheet protection
⋮----
protectionPassword?: string; // Hashed
⋮----
// Grid settings
⋮----
// Frozen panes
⋮----
// Zoom level (percentage)
⋮----
// Default row height and column width
⋮----
// Custom row heights (sparse storage)
⋮----
// Custom column widths (sparse storage)
⋮----
// Hidden rows and columns
⋮----
// Cells (sparse storage - only non-empty cells)
cells: Record<string, JSONCell>; // Key format: "R0C0" (row 0, col 0)
⋮----
// Merged cells
⋮----
// Conditional formatting rules
⋮----
// Data validations
⋮----
// Filters
⋮----
// Charts
⋮----
// Comments/Notes
comments?: Record<string, CellComment>; // Key format: "R0C0"
⋮----
// Print settings
⋮----
export interface JSONCell {
  // Value (for display)
  value?: string | number | boolean | null;
  
  // Formula (starts with '=')
  formula?: string;
  
  // Data type
  dataType?: CellDataType;
  
  // Formatting
  formatting?: CellFormatting;
  
  // Hyperlink
  hyperlink?: string;
  
  // Note/Comment reference
  note?: string;
}
⋮----
// Value (for display)
⋮----
// Formula (starts with '=')
⋮----
// Data type
⋮----
// Formatting
⋮----
// Hyperlink
⋮----
// Note/Comment reference
⋮----
export interface MergedCellRange {
  startRow: number;
  startCol: number;
  endRow: number;
  endCol: number;
}
⋮----
export interface ConditionalFormat {
  id: string;
  priority: number;
  ranges: CellRange[];
  rule: ConditionalFormatRule;
  formatting: CellFormatting;
  stopIfTrue?: boolean;
}
⋮----
export interface CellRange {
  startRow: number;
  startCol: number;
  endRow: number;
  endCol: number;
}
⋮----
export type ConditionalFormatRule = 
  | { type: 'cellValue'; operator: 'greaterThan' | 'lessThan' | 'equal' | 'notEqual' | 'between'; values: (string | number)[] }
  | { type: 'formula'; formula: string }
  | { type: 'colorScale'; minColor: string; midColor?: string; maxColor: string }
  | { type: 'dataBar'; color: string; showValue?: boolean }
  | { type: 'iconSet'; iconSet: string; showValue?: boolean }
  | { type: 'top10'; rank: number; bottom?: boolean }
  | { type: 'aboveAverage'; aboveAverage: boolean }
  | { type: 'duplicateValues'; unique?: boolean }
  | { type: 'textContains'; text: string };
⋮----
export interface DataValidation {
  ranges: CellRange[];
  rule: DataValidationRule;
  showInputMessage?: boolean;
  inputTitle?: string;
  inputMessage?: string;
  showErrorMessage?: boolean;
  errorTitle?: string;
  errorMessage?: string;
  errorStyle?: 'stop' | 'warning' | 'information';
}
⋮----
export type DataValidationRule =
  | { type: 'list'; source: string[]; allowBlank?: boolean }
  | { type: 'number'; operator: 'between' | 'notBetween' | 'equal' | 'notEqual' | 'greaterThan' | 'lessThan' | 'greaterThanOrEqual' | 'lessThanOrEqual'; values: number[]; allowBlank?: boolean }
  | { type: 'date'; operator: string; values: string[]; allowBlank?: boolean }
  | { type: 'textLength'; operator: string; values: number[]; allowBlank?: boolean }
  | { type: 'custom'; formula: string };
⋮----
export interface AutoFilter {
  range: CellRange;
  filters: Record<number, ColumnFilter>; // Column index to filter
}
⋮----
filters: Record<number, ColumnFilter>; // Column index to filter
⋮----
export interface ColumnFilter {
  type: 'values' | 'custom';
  values?: (string | number)[];
  customFilter?: {
    operator: 'and' | 'or';
    conditions: FilterCondition[];
  };
}
⋮----
export interface FilterCondition {
  operator: 'equal' | 'notEqual' | 'greaterThan' | 'lessThan' | 'contains' | 'startsWith' | 'endsWith';
  value: string | number;
}
⋮----
export interface Chart {
  id: string;
  type: 'line' | 'bar' | 'column' | 'pie' | 'scatter' | 'area' | 'doughnut' | 'radar';
  title?: string;
  position: ChartPosition;
  dataRanges: ChartDataRange[];
  xAxisTitle?: string;
  yAxisTitle?: string;
  legend?: {
    position: 'top' | 'bottom' | 'left' | 'right' | 'none';
  };
  style?: ChartStyle;
}
⋮----
export interface ChartPosition {
  row: number;
  col: number;
  width: number;
  height: number;
}
⋮----
export interface ChartDataRange {
  name?: string;
  xValues?: string; // Range reference
  yValues: string; // Range reference
  color?: string;
}
⋮----
xValues?: string; // Range reference
yValues: string; // Range reference
⋮----
export interface ChartStyle {
  colors?: string[];
  fontSize?: number;
  fontFamily?: string;
}
⋮----
export interface CellComment {
  author: string;
  text: string;
  timestamp: string;
  replies?: CellComment[];
}
⋮----
export interface PrintSettings {
  paperSize?: string;
  orientation?: 'portrait' | 'landscape';
  margins?: {
    top: number;
    right: number;
    bottom: number;
    left: number;
    header: number;
    footer: number;
  };
  scaling?: number; // percentage
  fitToPage?: {
    width: number;
    height: number;
  };
  printArea?: CellRange;
  printTitles?: {
    rows?: string; // e.g., "1:2"
    columns?: string; // e.g., "A:B"
  };
  gridlines?: boolean;
  blackAndWhite?: boolean;
  draftQuality?: boolean;
  pageOrder?: 'downThenOver' | 'overThenDown';
  headerFooter?: {
    header?: string;
    footer?: string;
  };
}
⋮----
scaling?: number; // percentage
⋮----
rows?: string; // e.g., "1:2"
columns?: string; // e.g., "A:B"
⋮----
// AI Actions
export type WorkbookAction = 
  | { type: 'setCellValue'; sheetId: string; row: number; col: number; value: string | number | boolean }
  | { type: 'setCellFormula'; sheetId: string; row: number; col: number; formula: string }
  | { type: 'setRange'; sheetId: string; startRow: number; startCol: number; endRow: number; endCol: number; values: (string | number | boolean)[][] }
  | { type: 'setFormulaRange'; sheetId: string; startRow: number; startCol: number; endRow: number; endCol: number; formulas: string[][] }
  | { type: 'clearRange'; sheetId: string; startRow: number; startCol: number; endRow: number; endCol: number }
  | { type: 'formatCells'; sheetId: string; ranges: CellRange[]; formatting: CellFormatting }
  | { type: 'mergeCells'; sheetId: string; range: MergedCellRange }
  | { type: 'unmergeCells'; sheetId: string; range: MergedCellRange }
  | { type: 'addSheet'; name: string; position?: number }
  | { type: 'deleteSheet'; sheetId: string }
  | { type: 'renameSheet'; sheetId: string; name: string }
  | { type: 'insertRows'; sheetId: string; startRow: number; count: number }
  | { type: 'deleteRows'; sheetId: string; startRow: number; count: number }
  | { type: 'insertColumns'; sheetId: string; startCol: number; count: number }
  | { type: 'deleteColumns'; sheetId: string; startCol: number; count: number }
  | { type: 'setColumnWidth'; sheetId: string; col: number; width: number }
  | { type: 'setRowHeight'; sheetId: string; row: number; height: number }
  | { type: 'addConditionalFormat'; sheetId: string; format: ConditionalFormat }
  | { type: 'addDataValidation'; sheetId: string; validation: DataValidation }
  | { type: 'addChart'; sheetId: string; chart: Chart }
  | { type: 'addComment'; sheetId: string; row: number; col: number; comment: CellComment };

================
File: client/src/lib/utils.ts
================
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';
⋮----
/**
 * Merge Tailwind CSS classes intelligently
 */
export function cn(...inputs: ClassValue[])

================
File: client/src/lib/workbook/adapters/exceljs.ts
================
/**
 * ExcelJS Export Adapter
 * High-fidelity Excel export using ExcelJS library
 * Supports: formulas, styles, comments, data validations, conditional formats, images, tables
 */
⋮----
import type { ExportAdapter, WorkbookJSON, SheetJSON, Cell } from "../types";
import { parseAddress } from "../utils";
⋮----
export class ExcelJSAdapter implements ExportAdapter
⋮----
formulaCache: true, // We preserve computed values alongside formulas
styles: true, // Full style support (fonts, fills, borders, alignment)
⋮----
comments: true, // Threaded comments support
⋮----
conditionalFormats: true, // Rich conditional formatting
charts: false, // Not implemented yet (would need image generation)
images: true, // Embedded images support
namedRanges: true, // Workbook and sheet-scoped named ranges
⋮----
async export(workbook: WorkbookJSON): Promise<ArrayBuffer>
⋮----
// Dynamic import to avoid bundling if not used
⋮----
// Collect unsupported features for export warnings
⋮----
// Set workbook properties
⋮----
// Add sheets
⋮----
// Set sheet properties (tabColor requires properties object)
⋮----
// Add cells
⋮----
const excelRow = row; // ExcelJS uses 1-based indexing
⋮----
// Ensure row exists
⋮----
// Set value and formula
⋮----
// ExcelJS requires setting value as object with formula and result
⋮----
// Set number format
⋮----
// Set style
⋮----
// Add comment if present in sheet comments
⋮----
// Add merges
⋮----
// Set column widths
⋮----
ws.getColumn(col).width = colMeta.width / 7; // Approximate conversion
⋮----
// Set row heights
⋮----
// Add data validations
⋮----
// ExcelJS validation implementation - TODO
// ws.getCell(validation.range).dataValidation = { ... };
⋮----
// Add named ranges - TODO: ExcelJS named ranges implementation
// if (workbook.namedRanges) {
//   for (const [name, range] of Object.entries(workbook.namedRanges)) {
//     wb.definedNames.add(name, range);
//   }
// }
⋮----
// Store warnings in workbook for persistence
⋮----
// Write to buffer
⋮----
async import(data: Blob | ArrayBuffer): Promise<WorkbookJSON>
⋮----
// Convert Blob to ArrayBuffer if needed
⋮----
// Load workbook
⋮----
// Create WorkbookJSON structure
⋮----
// Import each worksheet
⋮----
private worksheetToSheet(worksheet: any): SheetJSON
⋮----
// Import cells
⋮----
// Import column properties
⋮----
width: col.width ? col.width * 7 : undefined, // Convert back
⋮----
// Import row properties
⋮----
// Import merged ranges
⋮----
private excelCellToCell(excelCell: any): Cell | null
⋮----
// Handle formulas
⋮----
// Store computed value if available
⋮----
// Regular value
⋮----
// Import number format
⋮----
// Import styles
⋮----
// Import comments - stored separately in sheet.comments
// Comments handled at sheet level
⋮----
private extractCellStyle(excelCell: any): any
⋮----
// Extract font
⋮----
// Extract fill
⋮----
// Extract alignment
⋮----
// Extract borders
⋮----
private toAddress(row: number, col: number): string
⋮----
private getTypeCode(type: any): string
⋮----
private getDataType(type: any): string
⋮----
private applyCellStyle(excelCell: any, style: any)
⋮----
// Apply font styles
⋮----
// Apply fill
⋮----
// Apply alignment
⋮----
// Apply borders (simplified)
⋮----
/**
   * Collect warnings for unsupported features in ExcelJS export
   */
private collectUnsupportedFeatures(workbook: WorkbookJSON, warnings: string[]): void
⋮----
// Check for charts (not yet implemented)
⋮----
// Check for pivot tables (not yet implemented)
⋮----
// Check for advanced conditional formats
⋮----
// Check for complex data validations
⋮----
// Check for named ranges (not yet implemented)

================
File: client/src/lib/workbook/adapters/sheetjs.ts
================
/**
 * SheetJS Export Adapter
 * Basic export/import using SheetJS (xlsx library)
 * Supports: formulas, basic styles, merges, column widths, row heights
 */
⋮----
import type { ExportAdapter, WorkbookJSON, SheetJSON, Cell } from "../types";
import { createWorkbook, generateId, parseAddress, toAddress } from "../utils";
⋮----
export class SheetJSAdapter implements ExportAdapter {
⋮----
formulaCache: true, // We preserve computed values (v field)
styles: false, // SheetJS has limited style support (requires paid version)
⋮----
comments: false, // limited support
⋮----
namedRanges: false, // Not implemented yet
⋮----
async export(workbook: WorkbookJSON): Promise<ArrayBuffer>
⋮----
// Dynamic import to avoid bundling if not used
⋮----
// Collect unsupported features for export warnings
⋮----
// Store warnings in workbook for persistence
⋮----
// Write workbook to array buffer
⋮----
async import(data: Blob | ArrayBuffer): Promise<WorkbookJSON>
⋮----
// Convert Blob to ArrayBuffer if needed
⋮----
// Read workbook
⋮----
// Create new workbook JSON
⋮----
workbook.sheets = []; // clear default sheet
⋮----
// Import each sheet
⋮----
private sheetToWorksheet(sheet: SheetJSON, XLSX: any, warnings: string[]): any
⋮----
// Add cells
⋮----
// Handle formulas
⋮----
// CRITICAL: Excel requires both f (formula) and v (cached value) for proper display
// Always write v, even if undefined, to ensure Excel doesn't show #VALUE!
⋮----
// Missing computed value - write error placeholder and warn
xlsxCell.v = 0; // Default fallback (Excel will recalculate on open)
⋮----
// Regular value
⋮----
// Add number format
⋮----
// Set cell type if known
⋮----
// Map dataType to SheetJS type
⋮----
// Add merges
⋮----
// Add column widths
⋮----
wch: colMeta.width ? colMeta.width / 7 : 10, // approximate conversion
⋮----
// Add row heights
⋮----
// Calculate range
⋮----
private worksheetToSheet(ws: any, name: string, XLSX: any): SheetJSON
⋮----
// Import cells
⋮----
// Handle formula
⋮----
// Regular value
⋮----
// Determine data type
⋮----
// Import number format
⋮----
// Import merges
⋮----
// Import column widths
⋮----
width: col.wch ? col.wch * 7 : 100, // approximate conversion
⋮----
// Import row heights
⋮----
/**
   * Collect warnings for unsupported features in SheetJS export
   */
private collectUnsupportedFeatures(workbook: WorkbookJSON, warnings: string[]): void
⋮----
// Check for styles (SheetJS free version doesn't support styles)
⋮----
// Check for comments
⋮----
// Check for data validations
⋮----
// Check for conditional formats
⋮----
// Check for charts
⋮----
// Check for images
⋮----
// Check for pivot tables
⋮----
// Check for named ranges

================
File: client/src/lib/workbook/api-example.ts
================
/**
 * API Usage Examples
 * 
 * This file demonstrates the clean public API exposed by index.ts
 * All examples follow best practices for the workbook module
 */
⋮----
import {
  // Workbook Creation & Loading
  createWorkbook,
  loadWorkbook,
  cloneWorkbook,
  
  // Workbook Export & Saving
  exportWorkbook,
  saveWorkbook,
  
  // Cell Operations
  setCell,
  getCell,
  
  // Operations & Undo/Redo
  applyOperations,
  createEditCellOp,
  createDeleteCellOp,
  createSetRangeOp,
  undoOperation,
  canUndoOperation,
  
  // Formula Computation
  computeFormulas,
  createFormulaEngine,
  disposeFormulaEngine,
  
  // Validation & Utilities
  validateWorkbook,
  getStats,
  getActionHistory,
  
  // Helper utilities
  getSheet,
  parseAddress,
  toAddress,
} from "./index";
⋮----
// Workbook Creation & Loading
⋮----
// Workbook Export & Saving
⋮----
// Cell Operations
⋮----
// Operations & Undo/Redo
⋮----
// Formula Computation
⋮----
// Validation & Utilities
⋮----
// Helper utilities
⋮----
// ============================================================================
// Example 1: Create a new workbook and add data
// ============================================================================
⋮----
export function example1_CreateWorkbook()
⋮----
// Create a new workbook
⋮----
// Validate it
⋮----
// Get stats
⋮----
// ============================================================================
// Example 2: Add data using low-level API (not recommended for production)
// ============================================================================
⋮----
export function example2_LowLevelCellOps()
⋮----
// Set some cells (low-level - not recommended)
⋮----
// Get a cell
⋮----
// ============================================================================
// Example 3: Add data using operations (recommended)
// ============================================================================
⋮----
export function example3_UsingOperations()
⋮----
// Create operations
⋮----
// Apply operations (without formula computation for now)
⋮----
skipRecompute: true, // Skip for now, we'll compute separately
⋮----
// Check action history
⋮----
// ============================================================================
// Example 4: Formula computation
// ============================================================================
⋮----
export function example4_FormulaComputation()
⋮----
// Create workbook with formulas
⋮----
// Compute all formulas
⋮----
// Check computed value
⋮----
// Don't forget to dispose!
⋮----
// ============================================================================
// Example 5: Undo/Redo with formula recomputation
// ============================================================================
⋮----
export function example5_UndoRedo()
⋮----
// Create HF instance for recomputation
⋮----
// Apply some operations
⋮----
// Apply another operation
⋮----
// Undo
⋮----
// Cleanup
⋮----
// ============================================================================
// Example 6: Batch operations with range
// ============================================================================
⋮----
export function example6_BatchOperations()
⋮----
// Create a range of cells
⋮----
// Apply in one operation
⋮----
// Check a cell
⋮----
console.log(`C3 value: ${cell?.raw}`); // Should be 3 * 3 = 9
⋮----
// ============================================================================
// Example 7: Export and load workbook
// ============================================================================
⋮----
export async function example7_ExportAndLoad()
⋮----
// Create workbook with data
⋮----
// Export to XLSX
⋮----
// Load it back
⋮----
// Verify data
⋮----
// ============================================================================
// Example 8: Clone workbook
// ============================================================================
⋮----
export function example8_CloneWorkbook()
⋮----
// Clone it
⋮----
// Modify clone
⋮----
// Verify original is unchanged
⋮----
console.log(`Original A1: ${originalCell?.raw}`); // Should be 100
console.log(`Clone A1: ${cloneCell?.raw}`); // Should be 999
⋮----
// ============================================================================
// Example 9: Address utilities
// ============================================================================
⋮----
export function example9_AddressUtilities()
⋮----
// Parse address
⋮----
console.log(`A1 -> row: ${addr1.row}, col: ${addr1.col}`); // row: 1, col: 1
⋮----
console.log(`Z10 -> row: ${addr2.row}, col: ${addr2.col}`); // row: 10, col: 26
⋮----
// Convert to address
⋮----
console.log(`row: 1, col: 1 -> ${address1}`); // A1
⋮----
console.log(`row: 10, col: 26 -> ${address2}`); // Z10
⋮----
console.log(`row: 100, col: 100 -> ${address3}`); // CV100
⋮----
// ============================================================================
// Run all examples
// ============================================================================
⋮----
export function runAllExamples()
⋮----
// Note: Example 7 is async, so it needs to be run separately
⋮----
// Uncomment to run examples
// runAllExamples();

================
File: client/src/lib/workbook/API.md
================
# Workbook Public API

This document describes the clean public API exposed by the workbook module through `index.ts`.

## Overview

The workbook module provides a comprehensive API for working with spreadsheet data in JSON format. All functionality is organized into logical groups for easy discovery and use.

## API Structure

### 1. Workbook Creation & Loading

```typescript
// Create a new empty workbook
function createWorkbook(title?: string): WorkbookJSON

// Load workbook from file (XLSX, CSV, etc.)
async function loadWorkbook(
  file: Blob | ArrayBuffer,
  adapter?: ExportAdapter
): Promise<WorkbookJSON>

// Clone (deep copy) a workbook
function cloneWorkbook(workbook: WorkbookJSON): WorkbookJSON
```

**Example:**
```typescript
import { createWorkbook, loadWorkbook, cloneWorkbook } from '@/lib/workbook';

// Create new workbook
const workbook = createWorkbook("My Spreadsheet");

// Load from file
const file = await fetch('/data.xlsx').then(r => r.blob());
const loadedWorkbook = await loadWorkbook(file);

// Clone workbook
const snapshot = cloneWorkbook(workbook);
```

### 2. Workbook Export & Saving

```typescript
// Export workbook to ArrayBuffer (XLSX format)
async function exportWorkbook(
  workbook: WorkbookJSON,
  adapter?: ExportAdapter
): Promise<ArrayBuffer>

// Save workbook to file (browser download)
async function saveWorkbook(
  workbook: WorkbookJSON,
  filename?: string,
  adapter?: ExportAdapter
): Promise<void>
```

**Example:**
```typescript
import { exportWorkbook, saveWorkbook } from '@/lib/workbook';

// Export to buffer
const buffer = await exportWorkbook(workbook);

// Or trigger browser download
await saveWorkbook(workbook, "my-spreadsheet.xlsx");
```

### 3. Cell Operations (Low-level)

> ⚠️ **Note:** These are low-level functions. For production use, prefer `applyOperations()`.

```typescript
// Set cell value
function setCell(
  workbook: WorkbookJSON,
  sheetId: string,
  address: string,
  cell: Cell
): void

// Get cell value
function getCell(
  workbook: WorkbookJSON,
  sheetId: string,
  address: string
): Cell | undefined

// Delete cell
function deleteCell(
  workbook: WorkbookJSON,
  sheetId: string,
  address: string
): void
```

**Example:**
```typescript
import { setCell, getCell, deleteCell } from '@/lib/workbook';

const sheet = workbook.sheets[0];

// Set cell (low-level)
setCell(workbook, sheet.id, "A1", { raw: 42 });

// Get cell
const cell = getCell(workbook, sheet.id, "A1");
console.log(cell?.raw); // 42

// Delete cell
deleteCell(workbook, sheet.id, "A1");
```

### 4. Operations & Undo/Redo (Recommended)

```typescript
// Apply operations to workbook
function applyOperations(
  workbook: WorkbookJSON,
  operations: AnyOperation[],
  options?: ApplyOptions
): ApplyResult

// Create operations
function createEditCellOp(
  sheetId: string,
  address: string,
  cell: Partial<Cell>
): EditCellOp

function createDeleteCellOp(
  sheetId: string,
  address: string
): DeleteCellOp

function createSetRangeOp(
  sheetId: string,
  range: string,
  cells: Record<string, Partial<Cell>>
): SetRangeOp

// Undo/Redo
function undoOperation(
  workbook: WorkbookJSON,
  options?: { hydration?: HydrationResult }
): UndoRedoResult

function canUndoOperation(workbook: WorkbookJSON): boolean
```

**Example:**
```typescript
import {
  applyOperations,
  createEditCellOp,
  createDeleteCellOp,
  undoOperation,
  canUndoOperation
} from '@/lib/workbook';

const sheet = workbook.sheets[0];

// Create operations
const operations = [
  createEditCellOp(sheet.id, "A1", { raw: 100 }),
  createEditCellOp(sheet.id, "A2", { raw: 200 }),
  createEditCellOp(sheet.id, "A3", { formula: "=A1+A2" }),
];

// Apply operations
const result = applyOperations(workbook, operations, {
  user: "user-123",
  hydration // Optional: for formula recomputation
});

if (result.success) {
  console.log(`Applied ${result.actions.length} actions`);
}

// Undo last operation
if (canUndoOperation(workbook)) {
  const undoResult = undoOperation(workbook, { hydration });
  console.log(`Undone: ${undoResult.action?.type}`);
}
```

### 5. Formula Computation

```typescript
// Compute all formulas in workbook
function computeFormulas(workbook: WorkbookJSON): {
  hydration: HydrationResult;
  recompute: RecomputeResult;
}

// Create HyperFormula instance (low-level)
function createFormulaEngine(workbook: WorkbookJSON): HydrationResult

// Dispose HyperFormula instance
function disposeFormulaEngine(
  hydration: HydrationResult | { hf: any }
): void
```

**Example:**
```typescript
import {
  computeFormulas,
  createFormulaEngine,
  disposeFormulaEngine
} from '@/lib/workbook';

// Compute all formulas
const { hydration, recompute } = computeFormulas(workbook);
console.log(`Computed ${recompute.updatedCells} cells`);
disposeFormulaEngine(hydration); // Don't forget!

// Or manage HF manually
const hydration = createFormulaEngine(workbook);
// ... use hydration.hf ...
disposeFormulaEngine(hydration);
```

### 6. Validation & Utilities

```typescript
// Validate workbook structure (basic TypeScript checks)
function validateWorkbook(workbook: any): workbook is WorkbookJSON

// Get workbook statistics
function getStats(workbook: WorkbookJSON): {
  sheets: number;
  cells: number;
  formulas: number;
  styledCells: number;
  size: number;
}

// Get action history
function getActionHistory(workbook: WorkbookJSON): Action[]
```

**Example:**
```typescript
import { validateWorkbook, getStats, getActionHistory } from '@/lib/workbook';

// Validate workbook
if (!validateWorkbook(workbook)) {
  console.error("Invalid workbook structure");
}

// Get statistics
const stats = getStats(workbook);
console.log(`${stats.sheets} sheets, ${stats.cells} cells, ${stats.formulas} formulas`);

// Get action history
const history = getActionHistory(workbook);
console.log(`${history.length} actions in history`);
```

### 7. Helper Functions

```typescript
// Sheet operations
function addSheet(workbook: WorkbookJSON, name?: string): SheetJSON
function getSheet(workbook: WorkbookJSON, sheetId: string): SheetJSON | undefined
function getSheetByName(workbook: WorkbookJSON, name: string): SheetJSON | undefined
function generateId(): string

// Address utilities
function parseAddress(address: string): { row: number; col: number }
function toAddress(row: number, col: number): string
function parseRange(range: string): { start: string; end: string }
function getCellsInRange(range: string): string[]
function isInRange(address: string, range: string): boolean

// HyperFormula coordinate conversion
function hfToAddress(row: number, col: number): string
function addressToHf(address: string): { row: number; col: number }
```

**Example:**
```typescript
import {
  addSheet,
  getSheet,
  parseAddress,
  toAddress,
  getCellsInRange
} from '@/lib/workbook';

// Add sheet
const newSheet = addSheet(workbook, "Sheet2");

// Get sheet
const sheet = getSheet(workbook, workbook.sheets[0].id);

// Address utilities
const { row, col } = parseAddress("A1"); // { row: 1, col: 1 }
const address = toAddress(10, 26); // "Z10"
const cells = getCellsInRange("A1:C3"); // ["A1", "A2", "A3", "B1", ...]
```

## Type Exports

All types are available for TypeScript users:

```typescript
import type {
  // Core types
  WorkbookJSON,
  SheetJSON,
  Cell,
  CellStyle,
  
  // Operations
  AnyOperation,
  EditCellOp,
  DeleteCellOp,
  ApplyResult,
  ApplyOptions,
  
  // Formula
  HydrationResult,
  RecomputeResult,
  
  // Undo/Redo
  UndoRedoResult,
  
  // Export
  ExportAdapter,
  
  // And many more...
} from '@/lib/workbook';
```

## Best Practices

### ✅ DO

1. **Use `applyOperations()` for all mutations**
   ```typescript
   const result = applyOperations(workbook, operations, { hydration });
   ```

2. **Always dispose HyperFormula instances**
   ```typescript
   const hydration = createFormulaEngine(workbook);
   // ... use it ...
   disposeFormulaEngine(hydration);
   ```

3. **Check operation results**
   ```typescript
   const result = applyOperations(workbook, operations);
   if (!result.success) {
     console.error("Failed:", result.errors);
   }
   ```

4. **Validate workbooks from external sources**
   ```typescript
   const workbook = await loadWorkbook(file);
   if (!validateWorkbook(workbook)) {
     throw new Error("Invalid workbook");
   }
   ```

### ❌ DON'T

1. **Don't use low-level cell operations in production**
   ```typescript
   // ❌ Bad
   setCell(workbook, sheetId, "A1", { raw: 42 });
   
   // ✅ Good
   applyOperations(workbook, [
     createEditCellOp(sheetId, "A1", { raw: 42 })
   ]);
   ```

2. **Don't forget to dispose HyperFormula**
   ```typescript
   // ❌ Bad - memory leak!
   const { hydration } = computeFormulas(workbook);
   
   // ✅ Good
   const { hydration } = computeFormulas(workbook);
   disposeFormulaEngine(hydration);
   ```

3. **Don't mutate workbook directly**
   ```typescript
   // ❌ Bad
   workbook.sheets[0].cells["A1"] = { raw: 42 };
   
   // ✅ Good
   applyOperations(workbook, [
     createEditCellOp(sheet.id, "A1", { raw: 42 })
   ]);
   ```

## Advanced Features

For advanced use cases, the following low-level modules are also exported:

- **Converters**: `workbookToCellArray`, `cellArrayToWorkbook`, `getCellDisplayValue`
- **HyperFormula**: `hydrateHFFromWorkbook`, `recomputeAndPatchCache`, etc.
- **Undo/Redo**: `undo`, `redo`, `canUndo`, `canRedo`, etc.
- **Adapters**: `SheetJSAdapter`
- **React Hook**: `useWorkbook`

See the full exports in `index.ts` for details.

## Testing

See `api-example.ts` for comprehensive usage examples covering all common scenarios.

## Summary

The workbook module provides:

✅ **Clean API**: Simple, intuitive function names  
✅ **Type Safety**: Full TypeScript support  
✅ **Undo/Redo**: Built-in action tracking  
✅ **Formula Support**: HyperFormula integration  
✅ **Validation**: Basic structure validation  
✅ **Export/Import**: XLSX/CSV support via SheetJS  
✅ **React-friendly**: Immutable operations  
✅ **Well-documented**: JSDoc comments on all functions  

For questions or issues, refer to the inline documentation or the examples in `api-example.ts`.

================
File: client/src/lib/workbook/api.ts
================
/**
 * Workbook API - High-level interface
 * 
 * This module provides a clean, cohesive API for working with workbooks.
 * All the core functionality exposed in one place for easy consumption.
 * 
 * Design principles:
 * - Simple, intuitive function names
 * - Consistent error handling
 * - TypeScript type safety
 * - No external dependencies (except adapters)
 * - React-friendly (immutable operations)
 */
⋮----
import type {
  WorkbookJSON,
  Cell,
  ExportAdapter,
  Action,
} from "./types";
⋮----
import { SheetJSAdapter } from "./adapters/sheetjs";
⋮----
import type { HydrationResult } from "./hyperformula";
⋮----
import type { AnyOperation, ApplyOptions, ApplyResult } from "./operations";
⋮----
import type { UndoRedoResult } from "./undo";
⋮----
// ============================================================================
// Workbook Creation & Loading
// ============================================================================
⋮----
/**
 * Create a new empty workbook
 * 
 * @param title - Workbook title (default: "Untitled")
 * @returns New workbook with one empty sheet
 * 
 * @example
 * ```typescript
 * const workbook = createWorkbook("My Spreadsheet");
 * ```
 */
export function createWorkbook(title?: string): WorkbookJSON
⋮----
/**
 * Load workbook from file
 * 
 * Uses SheetJS adapter by default to import XLSX/XLS/CSV files.
 * 
 * @param file - File blob or ArrayBuffer
 * @param adapter - Optional custom adapter (default: SheetJSAdapter)
 * @returns Loaded workbook
 * 
 * @example
 * ```typescript
 * const file = await fetch('/data.xlsx').then(r => r.blob());
 * const workbook = await loadWorkbook(file);
 * ```
 */
export async function loadWorkbook(
  file: Blob | ArrayBuffer,
  adapter: ExportAdapter = new SheetJSAdapter()
): Promise<WorkbookJSON>
⋮----
/**
 * Clone (deep copy) a workbook
 * 
 * Useful for creating snapshots or implementing undo/redo.
 * 
 * @param workbook - Source workbook
 * @returns Deep copy of workbook
 * 
 * @example
 * ```typescript
 * const snapshot = cloneWorkbook(workbook);
 * ```
 */
export function cloneWorkbook(workbook: WorkbookJSON): WorkbookJSON
⋮----
// ============================================================================
// Workbook Export & Saving
// ============================================================================
⋮----
/**
 * Export workbook to file format
 * 
 * Uses SheetJS adapter by default to export as XLSX.
 * 
 * @param workbook - Source workbook
 * @param adapter - Optional custom adapter (default: SheetJSAdapter)
 * @returns ArrayBuffer ready for download
 * 
 * @example
 * ```typescript
 * const buffer = await exportWorkbook(workbook);
 * const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
 * const url = URL.createObjectURL(blob);
 * // Trigger download...
 * ```
 */
export async function exportWorkbook(
  workbook: WorkbookJSON,
  adapter: ExportAdapter = new SheetJSAdapter()
): Promise<ArrayBuffer>
⋮----
/**
 * Save workbook to file (browser download)
 * 
 * Convenience function that exports and triggers browser download.
 * 
 * @param workbook - Source workbook
 * @param filename - Download filename (default: workbook title)
 * @param adapter - Optional custom adapter
 * 
 * @example
 * ```typescript
 * await saveWorkbook(workbook, "my-spreadsheet.xlsx");
 * ```
 */
export async function saveWorkbook(
  workbook: WorkbookJSON,
  filename?: string,
  adapter: ExportAdapter = new SheetJSAdapter()
): Promise<void>
⋮----
// ============================================================================
// Cell Operations
// ============================================================================
⋮----
/**
 * Set cell value in workbook
 * 
 * This is a low-level function. For production use, prefer `applyOperations()`.
 * 
 * @param workbook - Target workbook (modified in place)
 * @param sheetId - Sheet ID
 * @param address - Cell address (e.g., "A1")
 * @param cell - Cell data
 * 
 * @example
 * ```typescript
 * setCell(workbook, sheet.id, "A1", { raw: 42 });
 * ```
 */
export function setCell(
  workbook: WorkbookJSON,
  sheetId: string,
  address: string,
  cell: Cell
): void
⋮----
/**
 * Get cell from workbook
 * 
 * @param workbook - Source workbook
 * @param sheetId - Sheet ID
 * @param address - Cell address (e.g., "A1")
 * @returns Cell data or undefined
 * 
 * @example
 * ```typescript
 * const cell = getCell(workbook, sheet.id, "A1");
 * console.log(cell?.raw); // 42
 * ```
 */
export function getCell(
  workbook: WorkbookJSON,
  sheetId: string,
  address: string
): Cell | undefined
⋮----
/**
 * Delete cell from workbook
 * 
 * This is a low-level function. For production use, prefer `applyOperations()`.
 * 
 * @param workbook - Target workbook (modified in place)
 * @param sheetId - Sheet ID
 * @param address - Cell address (e.g., "A1")
 * 
 * @example
 * ```typescript
 * deleteCell(workbook, sheet.id, "A1");
 * ```
 */
export function deleteCell(
  workbook: WorkbookJSON,
  sheetId: string,
  address: string
): void
⋮----
// ============================================================================
// Operations & Undo/Redo
// ============================================================================
⋮----
/**
 * Apply operations to workbook
 * 
 * This is the recommended way to mutate workbooks. Provides:
 * - Automatic undo/redo support
 * - Validation
 * - Formula recomputation
 * - Error handling with rollback
 * 
 * @param workbook - Target workbook (modified in place)
 * @param operations - Array of operations to apply
 * @param options - Apply options (hydration, user, etc.)
 * @returns ApplyResult with success status and actions
 * 
 * @example
 * ```typescript
 * const result = applyOperations(workbook, [
 *   createEditCellOp(sheet.id, "A1", { raw: 100 }),
 *   createEditCellOp(sheet.id, "A2", { formula: "=A1*2" })
 * ], { hydration });
 * 
 * if (result.success) {
 *   console.log("Applied", result.actions.length, "actions");
 * }
 * ```
 */
export function applyOperations(
  workbook: WorkbookJSON,
  operations: AnyOperation[],
  options?: ApplyOptions
): ApplyResult
⋮----
/**
 * Undo last operation
 * 
 * @param workbook - Target workbook (modified in place)
 * @param options - Options (hydration for recompute)
 * @returns UndoRedoResult with success status
 * 
 * @example
 * ```typescript
 * if (canUndo(workbook)) {
 *   const result = undo(workbook, { hydration });
 *   console.log("Undone:", result.action?.type);
 * }
 * ```
 */
export function undoOperation(
  workbook: WorkbookJSON,
  options?: { hydration?: HydrationResult }
): UndoRedoResult
⋮----
/**
 * Check if undo is available
 * 
 * @param workbook - Source workbook
 * @returns True if undo is possible
 * 
 * @example
 * ```typescript
 * const canUndo = canUndoOperation(workbook);
 * ```
 */
export function canUndoOperation(workbook: WorkbookJSON): boolean
⋮----
// ============================================================================
// Formula Computation
// ============================================================================
⋮----
/**
 * Compute all formulas in workbook
 * 
 * Creates HyperFormula instance, computes all formulas,
 * and caches results in workbook.
 * 
 * @param workbook - Target workbook (modified in place with computed values)
 * @returns Hydration result with HF instance (remember to dispose!)
 * 
 * @example
 * ```typescript
 * const { hydration, recompute } = computeFormulas(workbook);
 * console.log("Computed", recompute.updatedCells, "cells");
 * 
 * // Don't forget to dispose!
 * disposeHF(hydration.hf);
 * ```
 */
export function computeFormulas(workbook: WorkbookJSON):
⋮----
/**
 * Create HyperFormula instance from workbook
 * 
 * Lower-level function for manual HF management.
 * Don't forget to call `disposeHF()` when done!
 * 
 * @param workbook - Source workbook
 * @returns Hydration result with HF instance
 * 
 * @example
 * ```typescript
 * const hydration = createFormulaEngine(workbook);
 * // Use hydration.hf...
 * disposeHF(hydration.hf);
 * ```
 */
export function createFormulaEngine(workbook: WorkbookJSON): HydrationResult
⋮----
/**
 * Dispose HyperFormula instance
 * 
 * Call this when done with HF to free resources.
 * 
 * @param hydration - Hydration result or HF instance
 * 
 * @example
 * ```typescript
 * const hydration = createFormulaEngine(workbook);
 * // ... use HF ...
 * disposeFormulaEngine(hydration);
 * ```
 */
export function disposeFormulaEngine(
  hydration: HydrationResult | { hf: any }
): void
⋮----
// ============================================================================
// Validation & Utilities
// ============================================================================
⋮----
/**
 * Validate workbook structure
 * 
 * Performs basic TypeScript-level validation.
 * Does NOT validate JSON Schema (deferred to Phase 2).
 * 
 * @param workbook - Workbook to validate
 * @returns True if valid
 * 
 * @example
 * ```typescript
 * if (!validateWorkbook(workbook)) {
 *   console.error("Invalid workbook structure");
 * }
 * ```
 */
export function validateWorkbook(workbook: any): workbook is WorkbookJSON
⋮----
/**
 * Get workbook statistics
 * 
 * Returns counts of sheets, cells, formulas, etc.
 * 
 * @param workbook - Source workbook
 * @returns Statistics object
 * 
 * @example
 * ```typescript
 * const stats = getWorkbookStats(workbook);
 * console.log(`${stats.sheets} sheets, ${stats.cells} cells, ${stats.formulas} formulas`);
 * ```
 */
export function getStats(workbook: WorkbookJSON): ReturnType<typeof utils.getWorkbookStats>
⋮----
/**
 * Get action history
 * 
 * Returns all actions in the log for inspection or replay.
 * 
 * @param workbook - Source workbook
 * @returns Array of actions
 * 
 * @example
 * ```typescript
 * const history = getActionHistory(workbook);
 * history.forEach(action => {
 *   console.log(action.type, action.timestamp);
 * });
 * ```
 */
export function getActionHistory(workbook: WorkbookJSON): Action[]
⋮----
// ============================================================================
// Helper Functions
// ============================================================================
⋮----
/**
 * Create edit cell operation
 * 
 * Helper for creating editCell operations.
 * 
 * @param sheetId - Sheet ID
 * @param address - Cell address
 * @param cell - Cell data
 * @returns EditCellOp
 */
⋮----
/**
 * Create delete cell operation
 * 
 * Helper for creating deleteCell operations.
 * 
 * @param sheetId - Sheet ID
 * @param address - Cell address
 * @returns DeleteCellOp
 */
⋮----
/**
 * Create set range operation
 * 
 * Helper for creating setRange operations.
 * 
 * @param sheetId - Sheet ID
 * @param range - Range (e.g., "A1:B10")
 * @param cells - Cell data by address
 * @returns SetRangeOp
 */
⋮----
// ============================================================================
// Re-exports for convenience
// ============================================================================
⋮----
// Type re-exports

================
File: client/src/lib/workbook/converters.ts
================
/**
 * Conversion utilities between WorkbookJSON and legacy formats
 */
⋮----
import type { WorkbookJSON, Cell } from './types';
import { parseAddress, toAddress } from './utils';
⋮----
export interface LegacyCellData {
  value: string | number | boolean | null;
  formula?: string;
  formatting?: any;
}
⋮----
/**
 * Convert WorkbookJSON sheet to 2D array format for rendering
 */
export function workbookToCellArray(
  workbook: WorkbookJSON,
  sheetId: string,
  rows: number,
  cols: number
): LegacyCellData[][]
⋮----
// Populate cells from workbook
⋮----
const rowIdx = row - 1; // Convert to 0-based
⋮----
// Skip invalid addresses
⋮----
/**
 * Convert 2D cell array back to WorkbookJSON format
 */
export function cellArrayToWorkbook(
  cells: LegacyCellData[][],
  existingWorkbook?: WorkbookJSON
): WorkbookJSON
⋮----
const address = toAddress(r + 1, c + 1); // Convert to 1-based
⋮----
// Convert formatting
⋮----
/**
 * Get cell value for display (respects computed vs raw)
 */
export function getCellDisplayValue(cell: Cell): string | number | boolean | null
⋮----
/**
 * Create a Cell object from user input
 */
export function createCellFromInput(input: string): Cell
⋮----
// Formula
⋮----
// Number
⋮----
// Boolean
⋮----
// String

================
File: client/src/lib/workbook/demo.ts
================
/**
 * Workbook JSON Demo
 * Interactive demo to test the workbook functionality
 */
⋮----
import {
  createWorkbook,
  addSheet,
  setCell,
  getCell,
  parseAddress,
  toAddress,
  getWorkbookStats,
  SheetJSAdapter,
} from './index';
⋮----
export async function runDemo()
⋮----
// 1. Create workbook
⋮----
// 2. Add header row with styling
⋮----
// 3. Add data rows
⋮----
// Product name
⋮----
// Quarterly sales
⋮----
// Total formula
⋮----
// 4. Add totals row
⋮----
// 5. Add merge and comments
⋮----
// 6. Set column widths
⋮----
1: { width: 120 }, // Product
2: { width: 80 },  // Q1
3: { width: 80 },  // Q2
4: { width: 80 },  // Q3
5: { width: 80 },  // Q4
6: { width: 100 }, // Total
⋮----
// 7. Add second sheet for charts metadata
⋮----
// 8. Display stats
⋮----
// 9. Test address conversions
⋮----
// 10. Export to XLSX
⋮----
// 11. Re-import and verify
⋮----
// 12. Download option
⋮----
/**
 * Download workbook as XLSX file
 */
export function downloadWorkbook(buffer: ArrayBuffer, filename: string)
⋮----
/**
 * Quick test function for browser console
 */
export async function quickTest()
⋮----
// Make available globally for console access
⋮----
// Auto-run if imported directly

================
File: client/src/lib/workbook/exceljs-adapter.test.ts
================
/**
 * ExcelJS Adapter Tests
 * Tests the high-fidelity Excel export functionality
 */
⋮----
import { ExcelJSAdapter, createWorkbook, setCell } from "./index";
⋮----
// Add some test data
⋮----
// Should return an ArrayBuffer
⋮----
// TODO: Import back and verify formula preservation
// const imported = await adapter.import(buffer);
// expect(imported.sheets[0].cells?.A3?.formula).toBe("=A1+A2");

================
File: client/src/lib/workbook/hyperformula.test.ts
================
/**
 * HyperFormula Integration Tests
 * 
 * Tests the hyperformula module functionality including:
 * - Hydration from WorkbookJSON
 * - Formula computation and caching
 * - Bidirectional coordinate mapping
 * - Incremental updates
 * - Error handling
 */
⋮----
import {
  hydrateHFFromWorkbook,
  recomputeAndPatchCache,
  computeWorkbook,
  updateCellsAndRecompute,
  getCellValueFromHF,
  isCellFormula,
  getCellFormulaFromHF,
  formatHFError,
  getHFStats,
  disposeHF,
} from "./hyperformula";
import { createWorkbook, setCell, getCell } from "./utils";
import type { WorkbookJSON, Cell } from "./types";
⋮----
/**
 * Run all HyperFormula tests
 */
export function runHyperFormulaTests(): void
⋮----
/**
 * Test 1: Basic hydration from workbook
 */
function testBasicHydration(): void
⋮----
// Add some cells
⋮----
// Hydrate HF
⋮----
// Verify sheet mapping
⋮----
// Verify no warnings
⋮----
// Verify HF has correct data
⋮----
// Cleanup
⋮----
/**
 * Test 2: Formula computation and result caching
 */
function testFormulaComputation(): void
⋮----
// Add formula cells
⋮----
// Compute workbook
⋮----
// Verify computation stats
⋮----
// Verify computed values
⋮----
// Verify cache metadata
⋮----
// Cleanup
⋮----
/**
 * Test 3: Cache persistence in workbook
 */
function testCachePersistence(): void
⋮----
// Add formula
⋮----
// Compute
⋮----
// Verify workbook-level cache
⋮----
// Verify cell-level cache
⋮----
// Cleanup
⋮----
/**
 * Test 4: Bidirectional coordinate mapping
 */
function testBidirectionalMapping(): void
⋮----
// Add cells with various addresses
⋮----
// Hydrate
⋮----
// Verify address mapping
⋮----
// Verify HF can read values at these addresses
⋮----
// Verify hfInternal was set
⋮----
// Cleanup
⋮----
/**
 * Test 5: Incremental updates
 */
function testIncrementalUpdates(): void
⋮----
// Initial setup
⋮----
// Initial compute
⋮----
// Verify initial value
⋮----
// Update A1
⋮----
// Update workbook cell (simulate user edit)
⋮----
// Recompute
⋮----
// Verify updated value
⋮----
// Cleanup
⋮----
/**
 * Test 6: Error handling
 */
function testErrorHandling(): void
⋮----
// Add cells with errors
⋮----
setCell(workbook, sheet.id, "B1", { formula: "=A1/A2" }); // Division by zero
setCell(workbook, sheet.id, "B2", { formula: "=INVALID()" }); // Invalid function
setCell(workbook, sheet.id, "B3", { formula: "=A1+#REF!" }); // Invalid reference
⋮----
// Compute
⋮----
// Verify errors were captured
⋮----
// Verify error in computed cache
⋮----
// Test error formatting
⋮----
// Cleanup
⋮----
/**
 * Test 7: Dependency tracking
 */
function testDependencyTracking(): void
⋮----
// Create dependency chain: A1 <- B1 <- C1
⋮----
// Compute
⋮----
// Verify dependency graph
⋮----
// Note: HF getDependents returns cells that depend on current cell,
// not cells that current cell depends on
// So we check if dependencies exist (not exact structure)
⋮----
// Cleanup
⋮----
/**
 * Test 8: Multi-sheet formulas
 */
function testMultiSheetFormulas(): void
⋮----
// Add second sheet
⋮----
// Add data
⋮----
// Compute
⋮----
// Verify sheet mapping
⋮----
// Verify cross-sheet formula
⋮----
// Cleanup
⋮----
/**
 * Test 9: Complex formulas
 */
function testComplexFormulas(): void
⋮----
// Add test data
⋮----
// Complex formulas
⋮----
// Compute
⋮----
// Verify results
⋮----
// Cleanup
⋮----
/**
 * Test 10: HF disposal and cleanup
 */
function testHFDisposal(): void
⋮----
// Create and dispose HF
⋮----
// Dispose
⋮----
// Verify can't use after disposal (should not crash)
⋮----
// Expected - HF should throw after disposal
⋮----
// Export test runner

================
File: client/src/lib/workbook/hyperformula.ts
================
/**
 * HyperFormula Integration Module
 * 
 * This module bridges WorkbookJSON with HyperFormula for formula computation.
 * 
 * Key responsibilities:
 * 1. Hydrate HF instance from WorkbookJSON
 * 2. Compute formulas and cache results back to workbook
 * 3. Maintain bidirectional mapping between Excel addresses and HF coordinates
 * 4. Track dependencies for incremental updates
 * 
 * Design principles:
 * - Keep HF instance isolated (don't expose internals to UI)
 * - Cache computed values in workbook.computed for persistence
 * - Use HF's batch operations for performance
 * - Handle errors gracefully (mark cells with error values)
 */
⋮----
import HyperFormulaNamespace, { type ConfigParams } from "hyperformula";
import type {
  WorkbookJSON,
  ComputedValue,
} from "./types";
import { hfToAddress, addressToHf } from "./utils";
⋮----
// Extract HyperFormula class from the namespace
⋮----
// Type for HyperFormula instance
type HyperFormulaInstance = ReturnType<typeof HyperFormula.buildEmpty>;
⋮----
// ============================================================================
// Configuration
// ============================================================================
⋮----
/**
 * Default HyperFormula configuration
 * Optimized for Excel compatibility and performance
 */
⋮----
licenseKey: "gpl-v3", // Use GPL v3 license
useArrayArithmetic: true, // Support array formulas
useColumnIndex: false, // Use A1 notation
useStats: false, // Disable stats collection for performance
smartRounding: true, // Round floating point precision
precisionRounding: 14, // Excel-like precision
⋮----
functionArgSeparator: ",", // Use comma separator
decimalSeparator: ".", // Use period for decimals
thousandSeparator: ",", // Use comma for thousands
nullYear: 1900, // Excel base year
leapYear1900: true, // Excel leap year bug compatibility
⋮----
// ============================================================================
// Types
// ============================================================================
⋮----
/**
 * Result of hydration operation
 */
export interface HydrationResult {
  hf: HyperFormulaInstance;
  sheetMap: Map<string, number>; // sheetId -> HF sheet index (0-based)
  addressMap: Map<string, string>; // "Sheet1!A1" -> cell address for lookups
  warnings: string[];
}
⋮----
sheetMap: Map<string, number>; // sheetId -> HF sheet index (0-based)
addressMap: Map<string, string>; // "Sheet1!A1" -> cell address for lookups
⋮----
/**
 * Result of recompute operation
 */
export interface RecomputeResult {
  updatedCells: number;
  errors: Array<{ address: string; sheetId: string; error: string }>;
  warnings: string[];
}
⋮----
/**
 * Options for hydration
 */
export interface HydrationOptions {
  config?: Partial<ConfigParams>;
  validateFormulas?: boolean; // Default: true
  skipCache?: boolean; // Skip loading cached computed values (default: false)
}
⋮----
validateFormulas?: boolean; // Default: true
skipCache?: boolean; // Skip loading cached computed values (default: false)
⋮----
/**
 * Options for recompute
 */
export interface RecomputeOptions {
  affectedRanges?: Array<{ sheetId: string; range: string }>; // Specific ranges to recompute
  fullRecompute?: boolean; // Force full recompute (ignore dependencies)
}
⋮----
affectedRanges?: Array<{ sheetId: string; range: string }>; // Specific ranges to recompute
fullRecompute?: boolean; // Force full recompute (ignore dependencies)
⋮----
// ============================================================================
// Core Functions
// ============================================================================
⋮----
/**
 * Create HyperFormula instance from WorkbookJSON
 * 
 * This is the main entry point for formula computation.
 * Loads all sheets and formulas into HF engine.
 * 
 * @param workbook - Source workbook
 * @param options - Hydration options
 * @returns HydrationResult with HF instance and mappings
 */
export function hydrateHFFromWorkbook(
  workbook: WorkbookJSON,
  options: HydrationOptions = {}
): HydrationResult
⋮----
// Initialize HF with empty instance
⋮----
// Create sheet mapping (sheetId -> HF sheet index)
⋮----
// Add sheets to HF in order
⋮----
// Add sheet to HF
⋮----
// First sheet is created by default, rename it
⋮----
// Add subsequent sheets
⋮----
// Load cell data into HF
⋮----
// Convert cells to HF format
⋮----
// Store address mapping for lookups
⋮----
// Determine cell value for HF
⋮----
// Load formula (HF expects formulas with = prefix)
⋮----
// Load raw value
⋮----
// Load cached computed value if available
⋮----
// Empty cell
⋮----
// Update hfInternal mapping
⋮----
// Batch load cells into HF for performance
⋮----
// Validate formulas if requested
⋮----
// Check for errors
⋮----
/**
 * Recompute formulas and patch results back to workbook
 * 
 * This function:
 * 1. Triggers HF computation (if needed)
 * 2. Extracts computed values from HF
 * 3. Updates cell.computed cache
 * 4. Updates workbook.computed.hfCache
 * 5. Tracks dependencies in workbook.computed.dependencyGraph
 * 
 * @param workbook - Target workbook (modified in place)
 * @param hydration - Result from hydrateHFFromWorkbook
 * @param options - Recompute options
 * @returns RecomputeResult with stats and errors
 */
export function recomputeAndPatchCache(
  workbook: WorkbookJSON,
  hydration: HydrationResult,
  options: RecomputeOptions = {}
): RecomputeResult
⋮----
// Initialize computed cache if not present
⋮----
// Process all sheets
⋮----
// Get sheet dimensions from HF
⋮----
// Iterate through cells with formulas
⋮----
if (!cell.formula) continue; // Skip non-formula cells
⋮----
// Skip if out of bounds
⋮----
// Get computed value from HF
⋮----
// Create computed value object
⋮----
// Handle different value types
⋮----
computed.t = "s"; // Empty string type
⋮----
// Handle HF error
⋮----
// Unknown type
⋮----
// Update cell computed cache
⋮----
// Update workbook-level cache
⋮----
// Get dependencies (cells this formula depends on)
⋮----
// Dependencies not critical, just log warning
⋮----
// Update workbook metadata
⋮----
/**
 * Create HF instance and perform full computation pipeline
 * 
 * Convenience function that combines hydration + recompute.
 * Use this for initial load or full refresh.
 * 
 * @param workbook - Source workbook (modified in place)
 * @param options - Combined hydration + recompute options
 * @returns Combined result with HF instance and computation stats
 */
export function computeWorkbook(
  workbook: WorkbookJSON,
  options: HydrationOptions & RecomputeOptions = {}
):
⋮----
// Hydrate HF from workbook
⋮----
// Recompute and patch cache
⋮----
/**
 * Update specific cells in HF and recompute affected formulas
 * 
 * Use this for incremental updates (e.g., user edits a cell).
 * More efficient than full recompute.
 * 
 * @param workbook - Target workbook
 * @param hydration - Existing HF instance
 * @param updates - Array of cell updates { sheetId, address, value }
 * @returns RecomputeResult with affected cells
 */
export function updateCellsAndRecompute(
  workbook: WorkbookJSON,
  hydration: HydrationResult,
  updates: Array<{ sheetId: string; address: string; value: any }>
): RecomputeResult
⋮----
// Apply updates to HF
⋮----
// Recompute affected cells
⋮----
/**
 * Get cell value from HF instance
 * 
 * Utility for reading computed values without patching workbook.
 * 
 * @param hf - HyperFormula instance
 * @param sheetId - HF sheet ID (0-based)
 * @param address - Cell address (e.g., "A1")
 * @returns Computed value or null
 */
export function getCellValueFromHF(
  hf: HyperFormulaInstance,
  sheetId: number,
  address: string
): any
⋮----
/**
 * Check if cell contains formula in HF
 * 
 * @param hf - HyperFormula instance
 * @param sheetId - HF sheet ID (0-based)
 * @param address - Cell address (e.g., "A1")
 * @returns True if cell has formula
 */
export function isCellFormula(
  hf: HyperFormulaInstance,
  sheetId: number,
  address: string
): boolean
⋮----
/**
 * Get formula string from HF
 * 
 * @param hf - HyperFormula instance
 * @param sheetId - HF sheet ID (0-based)
 * @param address - Cell address (e.g., "A1")
 * @returns Formula string (without = prefix) or null
 */
export function getCellFormulaFromHF(
  hf: HyperFormulaInstance,
  sheetId: number,
  address: string
): string | null
⋮----
// ============================================================================
// Helper Functions
// ============================================================================
⋮----
/**
 * Convert HF error to user-friendly message
 */
export function formatHFError(error: any): string
⋮----
/**
 * Get HF statistics for debugging
 */
export function getHFStats(hf: HyperFormulaInstance):
⋮----
/**
 * Dispose HF instance and cleanup resources
 * 
 * Call this when workbook is closed or component unmounts.
 */
export function disposeHF(hf: HyperFormulaInstance): void
⋮----
// Re-export HyperFormula class and type for external usage

================
File: client/src/lib/workbook/index.ts
================
/**
 * Workbook JSON module
 * Single source of truth for spreadsheet data
 * 
 * This module provides a clean, cohesive API for working with workbooks.
 * All core functionality is exposed through the api module.
 */
⋮----
// ============================================================================
// Clean Public API (Recommended for most use cases)
// ============================================================================
⋮----
// Workbook Creation & Loading
⋮----
// Workbook Export & Saving
⋮----
// Cell Operations
⋮----
// Operations & Undo/Redo
⋮----
// Formula Computation
⋮----
// Validation & Utilities
⋮----
// Helper Functions
⋮----
// Re-exports for convenience
⋮----
// ============================================================================
// Type Exports
// ============================================================================
⋮----
// ============================================================================
// Adapter Exports
// ============================================================================
⋮----
// ============================================================================
// Validation Exports
// ============================================================================
⋮----
// ============================================================================
// React Hook
// ============================================================================
⋮----
// ============================================================================
// Advanced / Low-level Exports
// (Use these only if you need fine-grained control)
// ============================================================================
⋮----
// Converters
⋮----
// HyperFormula Integration (low-level)
⋮----
// Undo/Redo (low-level)
⋮----
// ============================================================================
// Test Utilities
// ============================================================================

================
File: client/src/lib/workbook/MIGRATION.md
================
# Workbook JSON Migration Guide

## Overview

We've created a new, battle-tested workbook JSON schema in `src/lib/workbook/` that follows industry best practices. This document explains the differences and how to migrate.

## Key Improvements

### 1. **Address-based cell keys** (`"A1"` vs `"R0C0"`)
- **Old**: `"R0C0"`, `"R1C5"` (0-based row/col)
- **New**: `"A1"`, `"B6"` (Excel-style addresses)
- **Why**: Direct mapping to Excel/SheetJS, more intuitive

### 2. **Separated `numFmt` and `style`**
- **Old**: Mixed in single `formatting` object
- **New**: `numFmt` (number format) separate from `style` (visual styling)
- **Why**: Matches Excel/ExcelJS APIs directly

### 3. **Computed value caching**
- **New**: `computed` field with `{ v, t, ts, hfVersion, computedBy }`
- **Why**: Store HyperFormula results with versioning for cache invalidation

### 4. **HyperFormula internals**
- **New**: `hfInternal` field with `{ sheetId, row, col, formulaId }`
- **Why**: Dramatically speeds up HF rehydration

### 5. **Export adapters**
- **New**: `ExportAdapter` interface with swappable implementations
- **Why**: Support multiple export formats (SheetJS, ExcelJS, CSV) without touching core code

### 6. **Action log for undo/redo**
- **New**: Proper undo/redo stack with inverse actions
- **Why**: Deterministic undo is critical for user experience

## Schema Comparison

### Old Schema (`jsonWorkbook.ts`)
```typescript
{
  version: "1.0.0",
  sheets: [{
    cells: {
      "R0C0": {
        value: "Hello",
        formula?: "=A1+1",
        formatting?: { bold: true, numberFormat: "#,##0" }
      }
    }
  }]
}
```

### New Schema (`workbook/`)
```typescript
{
  schemaVersion: "1.0",
  sheets: [{
    cells: {
      "A1": {
        raw: "Hello",
        dataType: "string",
        formula?: "=B1+1",
        computed?: { v: "result", ts: "2025-10-13...", hfVersion: "1.2.3" },
        numFmt?: "#,##0",
        style?: { bold: true, color: "#000" }
      }
    }
  }]
}
```

## Migration Strategy

### Option 1: Keep both schemas (recommended for now)
Keep the old `jsonWorkbook.ts` for existing code, gradually migrate features to new schema.

### Option 2: Write a migration function
```typescript
import { WorkbookJSON } from '@/lib/workbook';
import { JSONWorkbook } from '@/lib/db/jsonWorkbook';

function migrateOldToNew(old: JSONWorkbook): WorkbookJSON {
  // Convert R0C0 to A1, split formatting, etc.
  // See implementation below
}
```

### Option 3: Dual export
Support both schemas during transition:
- UI reads from new schema
- Export supports both old and new
- Import converts old to new automatically

## Implementation Plan

### Phase 1: Testing (Current)
1. ✅ Create new workbook schema in `src/lib/workbook/`
2. ✅ Add SheetJSAdapter for basic export
3. ⏳ Test round-trip (JSON → XLSX → JSON)
4. ⏳ Add migration utility

### Phase 2: Integration
1. Create React hook: `useWorkbook()`
2. Connect to UI components
3. Wire HyperFormula integration
4. Add undo/redo support

### Phase 3: Migration
1. Migrate existing code to use new schema
2. Deprecate old `jsonWorkbook.ts`
3. Add schema version detection

## Quick Start with New Schema

```typescript
import { createWorkbook, setCell, SheetJSAdapter } from '@/lib/workbook';

// Create workbook
const wb = createWorkbook("My Workbook");
const sheet = wb.sheets[0];

// Add cells
setCell(wb, sheet.id, "A1", {
  raw: "Sales",
  dataType: "string",
  style: { bold: true, fontSize: 14 }
});

setCell(wb, sheet.id, "A2", {
  raw: 100,
  dataType: "number",
  numFmt: "#,##0.00"
});

setCell(wb, sheet.id, "A3", {
  formula: "=SUM(A2:A2)",
  dataType: "formula",
  computed: { v: 100, ts: new Date().toISOString() }
});

// Export to XLSX
const adapter = new SheetJSAdapter();
const buffer = await adapter.export(wb);
// Download or save buffer
```

## Type Reference

See `src/lib/workbook/types.ts` for full type definitions:
- `WorkbookJSON` - Main workbook structure
- `SheetJSON` - Sheet with cells, merges, charts
- `Cell` - Cell with formula, value, styling
- `ExportAdapter` - Interface for export implementations

## Testing

Run the test file to verify functionality:
```bash
cd client
npm run dev
# In browser console:
import('./src/lib/workbook/test.ts')
```

## Questions?

Check `client/JSON_WORKBOOK.md` for the original spec or review:
- `src/lib/workbook/types.ts` - Type definitions
- `src/lib/workbook/utils.ts` - Core utilities
- `src/lib/workbook/adapters/sheetjs.ts` - Export adapter

================
File: client/src/lib/workbook/operations.test.ts
================
/**
 * Operations and Undo/Redo Tests
 * 
 * Tests the operations module and undo/redo functionality including:
 * - Basic operations (editCell, deleteCell, etc.)
 * - Operation validation
 * - Inverse action generation
 * - Action log management
 * - Undo/redo functionality
 * - Batch operations
 * - Error handling
 */
⋮----
import {
  applyOperations,
  createEditCellOp,
  createDeleteCellOp,
  createSetRangeOp,
  undo,
  canUndo,
  getUndoDepth,
  getRecentActions,
  getActionLogStats,
} from "./index";
import { createWorkbook, getCell, setCell } from "./utils";
import type { WorkbookJSON } from "./types";
⋮----
/**
 * Run all operations tests
 */
export function runOperationsTests(): void
⋮----
/**
 * Test 1: Basic editCell operation
 */
function testBasicEditCell(): void
⋮----
// Create operation
⋮----
// Apply operation
⋮----
// Verify success
⋮----
// Verify cell was updated
⋮----
// Verify action log
⋮----
// Verify inverse action exists
⋮----
/**
 * Test 2: Delete cell operation
 */
function testDeleteCell(): void
⋮----
// Set initial value
⋮----
// Clear action log from manual set
⋮----
// Create delete operation
⋮----
// Apply operation
⋮----
// Verify success
⋮----
// Verify cell was deleted
⋮----
// Verify inverse action can restore
⋮----
/**
 * Test 3: Action log management
 */
function testActionLogManagement(): void
⋮----
// Perform multiple operations
⋮----
// Verify action log
⋮----
// Test getUndoDepth
⋮----
// Test getRecentActions
⋮----
/**
 * Test 4: Inverse action generation
 */
function testInverseActions(): void
⋮----
// Edit cell (no previous value)
⋮----
// Verify inverse is deleteCell (since cell didn't exist)
⋮----
// Edit existing cell
⋮----
// Verify inverse is editCell with old value
⋮----
/**
 * Test 5: Basic undo
 */
function testBasicUndo(): void
⋮----
// Perform operation
⋮----
// Verify cell was set
⋮----
// Check canUndo
⋮----
// Undo
⋮----
// Verify undo succeeded
⋮----
// Verify cell was restored
⋮----
// Verify action log
⋮----
/**
 * Test 6: Multiple undo
 */
function testMultipleUndo(): void
⋮----
// Perform multiple operations
⋮----
// Verify all cells set
⋮----
// Undo last operation (A3)
⋮----
// Undo second operation (A2)
⋮----
// Undo first operation (A1)
⋮----
// Verify no more undo available
⋮----
/**
 * Test 7: Batch operations
 */
function testBatchOperations(): void
⋮----
// Create batch of operations
⋮----
// Apply all at once
⋮----
// Verify success
⋮----
// Verify all cells set
⋮----
/**
 * Test 8: Insert/Delete row
 */
function testInsertDeleteRow(): void
⋮----
// Set up initial cells
⋮----
// Clear action log
⋮----
// Insert row at position 2
⋮----
// Verify success
⋮----
// Verify cells shifted
⋮----
/**
 * Test 9: Insert/Delete column
 */
function testInsertDeleteCol(): void
⋮----
// Set up initial cells
⋮----
// Clear action log
⋮----
// Insert column at position 2 (B)
⋮----
col: 2, // Insert at column B
⋮----
// Verify success
⋮----
// Verify cells shifted
⋮----
/**
 * Test 10: Merge/Unmerge
 */
function testMergeUnmerge(): void
⋮----
// Merge range
⋮----
// Verify success
⋮----
// Verify merged range added
⋮----
// Unmerge
⋮----
// Verify success
⋮----
// Verify merged range removed
⋮----
/**
 * Test 11: Set style and format
 */
function testSetStyleFormat(): void
⋮----
// Set style
⋮----
// Verify success
⋮----
// Verify style applied
⋮----
// Set format
⋮----
// Verify success
⋮----
// Verify format applied
⋮----
/**
 * Test 12: Set range (batch edit)
 */
function testSetRange(): void
⋮----
// Create setRange operation
⋮----
// Verify success
⋮----
// Verify all cells set
⋮----
/**
 * Test 13: Operation validation
 */
function testOperationValidation(): void
⋮----
// Invalid sheet ID
⋮----
// Invalid address
⋮----
/**
 * Test 14: Error handling and rollback
 */
function testErrorHandling(): void
⋮----
// Set initial value
⋮----
// Clear action log
⋮----
// Create batch with one invalid operation
⋮----
createEditCellOp(sheet.id, "A1", { raw: 200 }), // Valid
createEditCellOp("invalid-sheet", "A2", { raw: 300 }), // Invalid
⋮----
// Verify failure
⋮----
// Verify rollback - A1 should still be 100
⋮----
// Verify no actions added to log
⋮----
/**
 * Test 15: Action log statistics
 */
function testActionLogStats(): void
⋮----
// Perform various operations
⋮----
// Get stats
⋮----
// Verify stats
⋮----
// Export test runner

================
File: client/src/lib/workbook/operations.ts
================
/**
 * Operations Module - Undo/Redo System
 * 
 * This module provides atomic operations for workbook mutations with:
 * - Automatic inverse action generation for undo
 * - Action log management
 * - HyperFormula integration for formula recomputation
 * - Validation and error handling
 * 
 * Design principles:
 * - All mutations go through applyOperations() for consistency
 * - Each operation generates its inverse automatically
 * - Operations are atomic (all or nothing)
 * - HF recompute is triggered only for affected ranges
 */
⋮----
import type {
  WorkbookJSON,
  Cell,
  Action,
  CellStyle,
} from "./types";
import type { HydrationResult } from "./hyperformula";
import { recomputeAndPatchCache } from "./hyperformula";
import {
  generateId,
  getSheet,
  getCell,
  setCell,
  deleteCell,
  parseAddress,
  toAddress,
  getCellsInRange,
} from "./utils";
⋮----
// ============================================================================
// Operation Types
// ============================================================================
⋮----
/**
 * Base operation interface
 */
export interface Operation {
  type: string;
  sheetId: string;
  [key: string]: any;
}
⋮----
/**
 * Edit or create a cell
 */
export interface EditCellOp extends Operation {
  type: "editCell";
  address: string;
  cell: Partial<Cell>;
}
⋮----
/**
 * Delete a cell
 */
export interface DeleteCellOp extends Operation {
  type: "deleteCell";
  address: string;
}
⋮----
/**
 * Insert row(s)
 */
export interface InsertRowOp extends Operation {
  type: "insertRow";
  row: number; // 1-based row number
  count?: number; // Default: 1
}
⋮----
row: number; // 1-based row number
count?: number; // Default: 1
⋮----
/**
 * Delete row(s)
 */
export interface DeleteRowOp extends Operation {
  type: "deleteRow";
  row: number; // 1-based row number
  count?: number; // Default: 1
}
⋮----
row: number; // 1-based row number
count?: number; // Default: 1
⋮----
/**
 * Insert column(s)
 */
export interface InsertColOp extends Operation {
  type: "insertCol";
  col: number; // 1-based column number
  count?: number; // Default: 1
}
⋮----
col: number; // 1-based column number
count?: number; // Default: 1
⋮----
/**
 * Delete column(s)
 */
export interface DeleteColOp extends Operation {
  type: "deleteCol";
  col: number; // 1-based column number
  count?: number; // Default: 1
}
⋮----
col: number; // 1-based column number
count?: number; // Default: 1
⋮----
/**
 * Merge cell range
 */
export interface MergeOp extends Operation {
  type: "merge";
  range: string; // "A1:B2"
}
⋮----
range: string; // "A1:B2"
⋮----
/**
 * Unmerge cell range
 */
export interface UnmergeOp extends Operation {
  type: "unmerge";
  range: string; // "A1:B2"
}
⋮----
range: string; // "A1:B2"
⋮----
/**
 * Set cell style
 */
export interface SetStyleOp extends Operation {
  type: "setStyle";
  address: string;
  style: CellStyle;
}
⋮----
/**
 * Set number format
 */
export interface SetFormatOp extends Operation {
  type: "setFormat";
  address: string;
  numFmt: string;
}
⋮----
/**
 * Set range of cells (batch edit)
 */
export interface SetRangeOp extends Operation {
  type: "setRange";
  range: string; // "A1:B10"
  cells: Record<string, Partial<Cell>>; // Address -> cell data
}
⋮----
range: string; // "A1:B10"
cells: Record<string, Partial<Cell>>; // Address -> cell data
⋮----
/**
 * Union of all operation types
 */
export type AnyOperation =
  | EditCellOp
  | DeleteCellOp
  | InsertRowOp
  | DeleteRowOp
  | InsertColOp
  | DeleteColOp
  | MergeOp
  | UnmergeOp
  | SetStyleOp
  | SetFormatOp
  | SetRangeOp;
⋮----
// ============================================================================
// Result Types
// ============================================================================
⋮----
/**
 * Result of applying operations
 */
export interface ApplyResult {
  success: boolean;
  actions: Action[]; // Actions added to log
  affectedRanges: Array<{ sheetId: string; range: string }>; // Ranges that need recompute
  errors: string[];
  warnings: string[];
}
⋮----
actions: Action[]; // Actions added to log
affectedRanges: Array<{ sheetId: string; range: string }>; // Ranges that need recompute
⋮----
/**
 * Options for applying operations
 */
export interface ApplyOptions {
  user?: string; // User ID for action attribution
  skipValidation?: boolean; // Skip validation (use with caution)
  skipRecompute?: boolean; // Skip HF recompute (useful for batch operations)
  hydration?: HydrationResult; // Existing HF instance (for recompute)
}
⋮----
user?: string; // User ID for action attribution
skipValidation?: boolean; // Skip validation (use with caution)
skipRecompute?: boolean; // Skip HF recompute (useful for batch operations)
hydration?: HydrationResult; // Existing HF instance (for recompute)
⋮----
// ============================================================================
// Main Apply Function
// ============================================================================
⋮----
/**
 * Apply operations atomically to workbook
 * 
 * This is the main entry point for all workbook mutations.
 * 
 * Features:
 * - Validates operations before applying
 * - Generates inverse actions for undo
 * - Updates action log
 * - Triggers HF recompute for affected ranges
 * - Rolls back on error (all-or-nothing)
 * 
 * @param workbook - Target workbook (modified in place)
 * @param operations - Array of operations to apply
 * @param options - Apply options
 * @returns ApplyResult with actions and affected ranges
 */
export function applyOperations(
  workbook: WorkbookJSON,
  operations: AnyOperation[],
  options: ApplyOptions = {}
): ApplyResult
⋮----
// Validate operations first
⋮----
// Create snapshot for rollback
⋮----
// Apply each operation
⋮----
// If any errors occurred, rollback
⋮----
// Add actions to log
⋮----
// Trim action log if it exceeds max size
const maxSize = 100; // Default max size
⋮----
// Update metadata
⋮----
// Trigger HF recompute if needed
⋮----
// Rollback on unexpected error
⋮----
// ============================================================================
// Operation Handlers
// ============================================================================
⋮----
/**
 * Apply single operation and generate inverse
 */
function applyOperation(
  workbook: WorkbookJSON,
  op: AnyOperation,
  options: ApplyOptions
):
⋮----
/**
 * Apply editCell operation
 */
function applyEditCell(
  workbook: WorkbookJSON,
  op: EditCellOp,
  options: ApplyOptions
): ReturnType<typeof applyOperation>
⋮----
// Get old cell value for inverse
⋮----
// Apply new cell
⋮----
// Create action with inverse
⋮----
// Mark affected range
⋮----
/**
 * Apply deleteCell operation
 */
function applyDeleteCell(
  workbook: WorkbookJSON,
  op: DeleteCellOp,
  options: ApplyOptions
): ReturnType<typeof applyOperation>
⋮----
// Get old cell for inverse
⋮----
// Delete cell
⋮----
// Create action with inverse
⋮----
/**
 * Apply insertRow operation
 */
function applyInsertRow(
  workbook: WorkbookJSON,
  op: InsertRowOp,
  options: ApplyOptions
): ReturnType<typeof applyOperation>
⋮----
// Shift cells down
⋮----
// Move cell down
⋮----
// Keep cell in place
⋮----
// Create action with inverse
⋮----
/**
 * Apply deleteRow operation
 */
function applyDeleteRow(
  workbook: WorkbookJSON,
  op: DeleteRowOp,
  options: ApplyOptions
): ReturnType<typeof applyOperation>
⋮----
// Save cells in deleted rows for inverse
⋮----
// Save for inverse
⋮----
// Move cell up
⋮----
// Keep cell in place
⋮----
// Create action with inverse
⋮----
deletedCells, // Store for inverse
⋮----
/**
 * Apply insertCol operation
 */
function applyInsertCol(
  workbook: WorkbookJSON,
  op: InsertColOp,
  options: ApplyOptions
): ReturnType<typeof applyOperation>
⋮----
// Shift cells right
⋮----
// Move cell right
⋮----
// Keep cell in place
⋮----
// Create action with inverse
⋮----
/**
 * Apply deleteCol operation
 */
function applyDeleteCol(
  workbook: WorkbookJSON,
  op: DeleteColOp,
  options: ApplyOptions
): ReturnType<typeof applyOperation>
⋮----
// Save cells in deleted columns for inverse
⋮----
// Save for inverse
⋮----
// Move cell left
⋮----
// Keep cell in place
⋮----
// Create action with inverse
⋮----
deletedCells, // Store for inverse
⋮----
/**
 * Apply merge operation
 */
function applyMerge(
  workbook: WorkbookJSON,
  op: MergeOp,
  options: ApplyOptions
): ReturnType<typeof applyOperation>
⋮----
// Add to merged ranges if not already present
⋮----
// Create action with inverse
⋮----
/**
 * Apply unmerge operation
 */
function applyUnmerge(
  workbook: WorkbookJSON,
  op: UnmergeOp,
  options: ApplyOptions
): ReturnType<typeof applyOperation>
⋮----
// Remove from merged ranges
⋮----
// Create action with inverse
⋮----
/**
 * Apply setStyle operation
 */
function applySetStyle(
  workbook: WorkbookJSON,
  op: SetStyleOp,
  options: ApplyOptions
): ReturnType<typeof applyOperation>
⋮----
// Get existing cell or create new one
⋮----
// Create action with inverse
⋮----
/**
 * Apply setFormat operation
 */
function applySetFormat(
  workbook: WorkbookJSON,
  op: SetFormatOp,
  options: ApplyOptions
): ReturnType<typeof applyOperation>
⋮----
// Get existing cell or create new one
⋮----
// Create action with inverse
⋮----
/**
 * Apply setRange operation (batch edit)
 */
function applySetRange(
  workbook: WorkbookJSON,
  op: SetRangeOp,
  options: ApplyOptions
): ReturnType<typeof applyOperation>
⋮----
// Save old cells for inverse
⋮----
// Apply new cells
⋮----
// Create action with inverse
⋮----
// ============================================================================
// Validation
// ============================================================================
⋮----
/**
 * Validation result
 */
interface ValidationResult {
  valid: boolean;
  errors: string[];
}
⋮----
/**
 * Validate operation before applying
 */
function validateOperation(
  workbook: WorkbookJSON,
  op: AnyOperation
): ValidationResult
⋮----
// Validate sheet exists
⋮----
// Type-specific validation
⋮----
// Validate address
⋮----
// Validate range
⋮----
// Validate row number
⋮----
// Validate column number
⋮----
// ============================================================================
// Helper Functions
// ============================================================================
⋮----
/**
 * Create editCell operation
 */
export function createEditCellOp(
  sheetId: string,
  address: string,
  cell: Partial<Cell>
): EditCellOp
⋮----
/**
 * Create deleteCell operation
 */
export function createDeleteCellOp(
  sheetId: string,
  address: string
): DeleteCellOp
⋮----
/**
 * Create setRange operation
 */
export function createSetRangeOp(
  sheetId: string,
  range: string,
  cells: Record<string, Partial<Cell>>
): SetRangeOp

================
File: client/src/lib/workbook/README.md
================
# Workbook JSON Module

**Battle-tested, production-ready workbook JSON schema for Nexcell.**

This module provides a single source of truth for spreadsheet data that survives formula engines, export formats, and UI changes.

## 🎯 Features

- ✅ **Address-based cells** (`"A1"`, `"B2"`) for Excel compatibility
- ✅ **Separated number formats and styles** (matches ExcelJS/SheetJS APIs)
- ✅ **Formula + computed value caching** (store user formulas AND results)
- ✅ **HyperFormula integration** (internal coordinates for fast rehydration)
- ✅ **Export adapter pattern** (swappable export formats)
- ✅ **Versioned schema** (`schemaVersion` for migrations)
- ✅ **Undo/redo support** (action log with inverse operations)
- ✅ **Full feature set** (merges, validations, conditional formats, charts, comments)

## 📦 Quick Start

```typescript
import { createWorkbook, setCell, SheetJSAdapter } from '@/lib/workbook';

// Create workbook
const wb = createWorkbook("My Workbook");
const sheet = wb.sheets[0];

// Add cells
setCell(wb, sheet.id, "A1", {
  raw: "Hello",
  dataType: "string",
  style: { bold: true }
});

setCell(wb, sheet.id, "A2", {
  formula: "=UPPER(A1)",
  dataType: "formula",
  computed: { v: "HELLO", ts: new Date().toISOString() }
});

// Export to XLSX
const adapter = new SheetJSAdapter();
const buffer = await adapter.export(wb);
```

## 📁 Module Structure

```
src/lib/workbook/
├── types.ts              # TypeScript interfaces (WorkbookJSON, Cell, etc.)
├── utils.ts              # Core utilities (createWorkbook, setCell, etc.)
├── index.ts              # Public API exports
├── adapters/
│   └── sheetjs.ts        # SheetJS export adapter
├── demo.ts               # Interactive demo (run in browser)
├── test.ts               # Unit tests
├── MIGRATION.md          # Migration guide from old schema
└── README.md             # This file
```

## 🧪 Testing

### Run Round-Trip Test (Critical Quality Gate)

The round-trip test verifies that formulas, values, merges, and structure survive export → import cycle without data loss. **This test MUST pass before shipping any export functionality.**

Run in browser console:
```javascript
import('@/lib/workbook/test-runner').then(m => m.runTests())
```

Or manually:
```javascript
import { runRoundTripTest } from '@/lib/workbook';
const success = await runRoundTripTest();
```

The test verifies:
- ✅ Formula preservation (both `f` and `v` fields)
- ✅ Computed value caching
- ✅ Number formats
- ✅ Merged ranges
- ✅ Column widths
- ✅ Row heights
- ✅ Data types (string, number, boolean)
- ✅ Complex formulas (SUM, IF, string concatenation)

### Run Demo in Browser

1. Start dev server:
   ```bash
   cd client
   npm run dev
   ```

2. Open browser console and run:
   ```javascript
   import('@/lib/workbook/demo').then(m => m.quickTest())
   ```

3. Download generated XLSX:
   ```javascript
   downloadWorkbook(workbookData.buffer, 'test.xlsx')
   ```

### Run Unit Tests

```javascript
import('@/lib/workbook/test')
```

## 📖 API Reference

### Core Functions

#### `createWorkbook(title?: string): WorkbookJSON`
Create a new empty workbook with one default sheet.

#### `addSheet(workbook, name?): SheetJSON`
Add a new sheet to the workbook.

#### `setCell(workbook, sheetId, address, cell): void`
Set cell value at address (e.g., "A1", "B5").

#### `getCell(workbook, sheetId, address): Cell | undefined`
Get cell at address.

#### `deleteCell(workbook, sheetId, address): void`
Delete cell at address.

### Address Utilities

#### `parseAddress(address: string): { row: number, col: number }`
Parse "A1" → `{ row: 1, col: 1 }` (1-based).

#### `toAddress(row: number, col: number): string`
Convert `{ row: 1, col: 1 }` → "A1".

#### `getCellsInRange(range: string): string[]`
Get all addresses in range: "A1:B2" → `["A1", "A2", "B1", "B2"]`.

#### `isInRange(address: string, range: string): boolean`
Check if address is within range.

### HyperFormula Utilities

#### `hfToAddress(row: number, col: number): string`
Convert HyperFormula 0-based coords to Excel address.

#### `addressToHf(address: string): { row: number, col: number }`
Convert Excel address to HyperFormula 0-based coords.

### Export Adapters

#### `SheetJSAdapter`
Basic export using SheetJS (xlsx).

**Features:**
- ✅ Formulas
- ✅ Merges
- ✅ Column widths / row heights
- ✅ Number formats
- ❌ Styles (requires SheetJS Pro)
- ❌ Comments (limited)

```typescript
const adapter = new SheetJSAdapter();
const buffer = await adapter.export(workbook);
const imported = await adapter.import(buffer);
```

## 🔧 Cell Object Structure

```typescript
{
  // User input
  raw?: string | number | boolean | null;  // What user typed
  dataType?: "string" | "number" | "boolean" | "date" | "formula" | "error";

  // Formula
  formula?: string;                        // "=SUM(A1:A3)"
  hfInternal?: {                           // HyperFormula internals
    sheetId: number;                       // 0-based
    row: number;
    col: number;
    formulaId?: string;
  };

  // Computed cache
  computed?: {
    v: any;                                // Result value
    t?: "n" | "s" | "b" | "e" | "d";     // SheetJS type
    ts: string;                            // Timestamp
    hfVersion?: string;                    // HF version
    computedBy?: string;                   // Who computed
    error?: string;
  };

  // Formatting
  numFmt?: string;                         // "#,##0.00", "mm/dd/yyyy"
  style?: {
    bold?: boolean;
    italic?: boolean;
    color?: string;
    bgColor?: string;
    fontSize?: number;
    fontFamily?: string;
    alignment?: { horizontal?, vertical?, wrapText? };
    border?: { top?, bottom?, left?, right? };
  };
  hyperlink?: { url: string, tooltip?: string };

  // Metadata
  notes?: string;
  metadata?: Record<string, any>;
  readOnly?: boolean;
}
```

## 📊 Workbook Structure

```typescript
{
  schemaVersion: "1.0",
  workbookId: "uuid",
  meta: {
    title: string;
    author: string;
    createdAt: string;      // ISO timestamp
    modifiedAt: string;
  },
  sheets: [
    {
      id: "sheet-id",
      name: "Sheet1",
      cells: { "A1": { ... }, "B2": { ... } },
      mergedRanges: ["A1:B2"],
      cols: { 1: { width: 100 } },
      rows: { 1: { height: 21 } },
      properties: {
        freeze: { row: 1, col: 0 },
        zoom: 100,
        gridLines: true
      },
      charts: [...],
      pivots: [...],
      comments: { "A1": [...] }
    }
  ],
  computed: {
    hfCache: { "Sheet1!A1": { v: "result", ts: "..." } },
    dependencyGraph: { "Sheet1!A1": ["Sheet1!B1"] }
  },
  actionLog: {
    actions: [...],
    currentIndex: 0
  }
}
```

## 🔄 Migration from Old Schema

See [MIGRATION.md](./MIGRATION.md) for detailed migration guide from the old `jsonWorkbook.ts` schema.

**Key differences:**
- Cell keys: `"R0C0"` → `"A1"`
- Formatting: single object → `numFmt` + `style`
- Added: `computed` cache, `hfInternal`, `actionLog`

## 🎨 Examples

### Basic Spreadsheet

```typescript
const wb = createWorkbook("Budget");
const sheet = wb.sheets[0];

// Header
setCell(wb, sheet.id, "A1", {
  raw: "Category",
  dataType: "string",
  style: { bold: true }
});

setCell(wb, sheet.id, "B1", {
  raw: "Amount",
  dataType: "string",
  style: { bold: true }
});

// Data
setCell(wb, sheet.id, "A2", { raw: "Food", dataType: "string" });
setCell(wb, sheet.id, "B2", { raw: 500, dataType: "number", numFmt: "$#,##0.00" });

setCell(wb, sheet.id, "A3", { raw: "Rent", dataType: "string" });
setCell(wb, sheet.id, "B3", { raw: 1200, dataType: "number", numFmt: "$#,##0.00" });

// Total
setCell(wb, sheet.id, "B4", {
  formula: "=SUM(B2:B3)",
  dataType: "formula",
  numFmt: "$#,##0.00",
  style: { bold: true }
});
```

### With Styling and Merges

```typescript
// Merge header
sheet.mergedRanges = ["A1:B1"];
setCell(wb, sheet.id, "A1", {
  raw: "Monthly Budget",
  dataType: "string",
  style: {
    bold: true,
    fontSize: 16,
    bgColor: "#4472C4",
    color: "#FFFFFF",
    alignment: { horizontal: "center" }
  }
});

// Set column widths
sheet.cols = {
  1: { width: 150 },
  2: { width: 100 }
};
```

### Export to XLSX

```typescript
import { SheetJSAdapter } from '@/lib/workbook';

const adapter = new SheetJSAdapter();
const buffer = await adapter.export(wb);

// Download in browser
const blob = new Blob([buffer], {
  type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
});
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = 'budget.xlsx';
a.click();
```

## 🚀 Roadmap

### Phase 1: Core (Complete)
- [x] TypeScript types
- [x] Core utilities
- [x] SheetJS adapter
- [x] Round-trip tests
- [x] Demo

### Phase 2: Integration (Next)
- [ ] React hook (`useWorkbook`)
- [ ] HyperFormula integration
- [ ] Undo/redo implementation
- [ ] UI components

### Phase 3: Advanced
- [ ] ExcelJS adapter (rich features)
- [ ] CSV adapter
- [ ] Collaborative editing
- [ ] Real-time sync

## 📝 Design Decisions

### Why address-based keys?
Direct mapping to Excel/SheetJS APIs. No coordinate translation needed.

### Why separate `numFmt` and `style`?
Matches Excel's internal model and ExcelJS/SheetJS APIs.

### Why store both `formula` and `computed`?
- `formula`: Source of truth (user intent)
- `computed`: Cache for UI performance (avoid re-calc)

### Why `hfInternal`?
Dramatically speeds up HyperFormula rehydration. Store HF's internal representation to avoid re-parsing.

### Why `ExportAdapter` interface?
Future-proof. Swap exporters (SheetJS, ExcelJS, CSV, Google Sheets) without touching core code.

## 🤝 Contributing

1. Run tests before committing
2. Update types if adding fields
3. Bump `schemaVersion` if breaking changes
4. Add migration guide for schema changes

## 📄 License

MIT

---

**Built with ❤️ for Nexcell**

================
File: client/src/lib/workbook/roundtrip.test.ts
================
/**
 * Round-Trip Test: SheetJS Export/Import
 * 
 * THE critical test - verifies that formulas, values, merges, and structure
 * survive export -> import cycle without data loss.
 * 
 * This test MUST pass before shipping any export functionality.
 */
⋮----
import {
  createWorkbook,
  setCell,
  getCell,
  SheetJSAdapter,
  type WorkbookJSON,
  type Cell,
} from "./index";
⋮----
// ============================================================================
// Test Data Setup
// ============================================================================
⋮----
function createTestWorkbook(): WorkbookJSON
⋮----
// === Test Case 0: Workbook properties ===
⋮----
// === Test Case 0b: Sheet properties ===
⋮----
row: 1,  // Freeze first row
col: 2,  // Freeze first two columns
⋮----
// === Test Case 1: Simple formulas with computed values ===
⋮----
// === Test Case 2: Complex formulas ===
⋮----
// === Test Case 3: Formula referencing other formulas ===
⋮----
v: 600, // 30 * 20
⋮----
// === Test Case 4: String formulas ===
⋮----
// === Test Case 5: Boolean and conditional formulas ===
⋮----
// === Test Case 6: Number formats ===
⋮----
// === Test Case 7: Merged ranges ===
⋮----
// === Test Case 8: Column widths ===
⋮----
1: { width: 150 }, // Column A
2: { width: 100 }, // Column B
3: { width: 120 }, // Column C
4: { width: 80, hidden: false }, // Column D
⋮----
// === Test Case 9: Row heights ===
⋮----
1: { height: 30 }, // Header row
2: { height: 21 }, // Default
⋮----
// ============================================================================
// Verification Functions
// ============================================================================
⋮----
interface TestResult {
  passed: boolean;
  message: string;
  details?: any;
}
⋮----
function verifyCell(
  original: Cell | undefined,
  imported: Cell | undefined,
  address: string
): TestResult
⋮----
// Check formula preservation (most critical)
⋮----
// Check computed value preservation (f + v pattern)
⋮----
// Check raw value preservation (for non-formula cells)
⋮----
// Check number format preservation
⋮----
function verifyMerges(
  original: string[],
  imported: string[]
): TestResult
⋮----
// Sort to ensure order doesn't matter
⋮----
function verifyColWidths(
  original: Record<number, { width?: number; hidden?: boolean }>,
  imported: Record<number, { width?: number; hidden?: boolean }>
): TestResult
⋮----
// Check if key columns exist (allow some tolerance for default widths)
⋮----
// Only check if original has explicit width
⋮----
// Allow 10% tolerance due to unit conversion (pixels <-> character width)
⋮----
function verifyRowHeights(
  original: Record<number, { height?: number; hidden?: boolean }>,
  imported: Record<number, { height?: number; hidden?: boolean }>
): TestResult
⋮----
// Allow small tolerance for height
⋮----
function verifyWorkbookProperties(
  original: WorkbookJSON,
  imported: WorkbookJSON
): TestResult
⋮----
// Check defaultRowHeight
⋮----
// Check defaultColWidth (allow 15% tolerance for unit conversion)
⋮----
// Check workbookView.activeTab
⋮----
function verifySheetProperties(
  original: WorkbookJSON["sheets"][0],
  imported: WorkbookJSON["sheets"][0]
): TestResult
⋮----
// Check freeze panes
⋮----
// Check zoom
⋮----
// Check tabColor
⋮----
// Check gridLines
⋮----
// ============================================================================
// Main Test Runner
// ============================================================================
⋮----
export async function runRoundTripTest(): Promise<boolean>
⋮----
// Step 1: Create test workbook
⋮----
// Step 2: Export to XLSX
⋮----
// Step 3: Import back
⋮----
// Step 4: Verify cells
⋮----
// Step 5: Verify structure
⋮----
// Verify workbook properties
⋮----
// Verify sheet properties
⋮----
// Verify merges
⋮----
// Verify column widths
⋮----
// Verify row heights
⋮----
// Summary
⋮----
// ============================================================================
// ExcelJS Round-Trip Test
// ============================================================================
⋮----
export async function runExcelJSRoundTripTest(): Promise<boolean>
⋮----
// Import ExcelJS adapter dynamically
⋮----
// Step 1: Create test workbook
⋮----
// Step 2: Export to XLSX
⋮----
// Step 3: Import back
⋮----
// Step 4: Verify cells
⋮----
// Step 5: Verify structure
⋮----
// Verify workbook properties
⋮----
// Verify sheet properties
⋮----
// Verify merges
⋮----
// Verify column widths
⋮----
// Verify row heights
⋮----
// Summary
⋮----
// Export for use in test runners or manual execution

================
File: client/src/lib/workbook/run-roundtrip-test.js
================
/**
 * Node.js test runner for round-trip tests
 * Run with: node run-roundtrip-test.js
 */
⋮----
async function runTests() {
⋮----
// Import the test module
⋮----
console.log("Starting workbook round-trip tests...\n");
⋮----
// Test 1: SheetJS adapter
const sheetjsSuccess = await runRoundTripTest();
⋮----
console.log("\n" + "=".repeat(70));
console.log("\n");
⋮----
// Test 2: ExcelJS adapter
const exceljsSuccess = await runExcelJSRoundTripTest();
⋮----
// Summary
⋮----
console.log("FINAL SUMMARY");
console.log("=".repeat(70));
console.log(`SheetJS Adapter:  ${sheetjsSuccess ? "✅ PASSED" : "❌ FAILED"}`);
console.log(`ExcelJS Adapter:  ${exceljsSuccess ? "✅ PASSED" : "❌ FAILED"}`);
⋮----
console.log("\n✅ ALL TESTS PASSED - Both adapters ready!");
process.exit(0);
⋮----
console.log("\n❌ SOME TESTS FAILED - Review errors above");
process.exit(1);
⋮----
console.error("\n❌ Fatal error running tests:");
console.error(error);
⋮----
runTests();

================
File: client/src/lib/workbook/samples/simple.json
================
{
  "schemaVersion": "1.0",
  "workbookId": "550e8400-e29b-41d4-a716-446655440000",
  "meta": {
    "title": "Simple Sample Workbook",
    "author": "Nexcell",
    "createdAt": "2025-10-14T19:00:00.000Z",
    "modifiedAt": "2025-10-14T19:00:00.000Z"
  },
  "sheets": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440001",
      "name": "Sheet1",
      "visible": true,
      "grid": {
        "rowCount": 1000,
        "colCount": 50
      },
      "cells": {
        "A1": {
          "raw": "Hello World",
          "dataType": "string",
          "style": {
            "bold": true,
            "fontSize": 14
          }
        },
        "A2": {
          "raw": 42,
          "dataType": "number",
          "numFmt": "#,##0"
        },
        "A3": {
          "formula": "=A2*2",
          "dataType": "formula",
          "computed": {
            "v": 84,
            "t": "n",
            "ts": "2025-10-14T19:00:00.000Z",
            "hfVersion": "2.6.0",
            "computedBy": "hf-2.6.0"
          },
          "numFmt": "#,##0"
        }
      }
    }
  ]
}

================
File: client/src/lib/workbook/schema.json
================
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://nexcell.dev/workbook-json-schema-v1.0.json",
  "title": "Workbook JSON Schema v1.0",
  "description": "Schema for Nexcell workbook JSON format",
  "type": "object",
  "required": ["schemaVersion", "workbookId", "meta", "sheets"],
  "properties": {
    "schemaVersion": {
      "type": "string",
      "description": "Schema version for migration support",
      "pattern": "^\\d+\\.\\d+$"
    },
    "workbookId": {
      "type": "string",
      "description": "Persistent UUID for the workbook",
      "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$"
    },
    "meta": {
      "type": "object",
      "required": ["createdAt", "modifiedAt"],
      "properties": {
        "title": { "type": "string" },
        "author": { "type": "string" },
        "company": { "type": "string" },
        "createdAt": { "type": "string", "format": "date-time" },
        "modifiedAt": { "type": "string", "format": "date-time" },
        "locale": { "type": "string" },
        "timezone": { "type": "string" },
        "description": { "type": "string" },
        "tags": { "type": "array", "items": { "type": "string" } }
      }
    },
    "sheets": {
      "type": "array",
      "minItems": 1,
      "items": { "$ref": "#/definitions/SheetJSON" }
    },
    "workbookProperties": {
      "type": "object",
      "properties": {
        "defaultRowHeight": { "type": "number", "minimum": 0 },
        "defaultColWidth": { "type": "number", "minimum": 0 },
        "workbookView": {
          "type": "object",
          "properties": {
            "firstSheet": { "type": "integer", "minimum": 0 },
            "activeTab": { "type": "integer", "minimum": 0 }
          }
        }
      }
    },
    "namedRanges": {
      "type": "object",
      "patternProperties": {
        "^.*$": { "type": "string" }
      }
    },
    "computed": {
      "type": "object",
      "properties": {
        "hfCache": {
          "type": "object",
          "patternProperties": {
            "^.*$": { "$ref": "#/definitions/ComputedValue" }
          }
        },
        "dependencyGraph": {
          "type": "object",
          "patternProperties": {
            "^.*$": { "type": "array", "items": { "type": "string" } }
          }
        }
      }
    },
    "actionLog": {
      "type": "array",
      "items": { "$ref": "#/definitions/Action" }
    },
    "aiPlans": {
      "type": "object",
      "additionalProperties": true
    },
    "exportWarnings": {
      "type": "array",
      "items": { "type": "string" },
      "description": "Warnings from export operations about unsupported features"
    }
  },
  "definitions": {
    "SheetJSON": {
      "type": "object",
      "required": ["id", "name", "grid"],
      "properties": {
        "id": { "type": "string", "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$" },
        "name": { "type": "string", "minLength": 1 },
        "visible": { "type": "boolean" },
        "grid": {
          "type": "object",
          "required": ["rowCount", "colCount"],
          "properties": {
            "rowCount": { "type": "integer", "minimum": 1 },
            "colCount": { "type": "integer", "minimum": 1 }
          }
        },
        "rows": {
          "type": "object",
          "patternProperties": {
            "^\\d+$": {
              "type": "object",
              "properties": {
                "height": { "type": "number", "minimum": 0 },
                "hidden": { "type": "boolean" }
              }
            }
          }
        },
        "cols": {
          "type": "object",
          "patternProperties": {
            "^\\d+$": {
              "type": "object",
              "properties": {
                "width": { "type": "number", "minimum": 0 },
                "hidden": { "type": "boolean" }
              }
            }
          }
        },
        "cells": {
          "type": "object",
          "patternProperties": {
            "^[A-Z]+\\d+$": { "$ref": "#/definitions/Cell" }
          }
        },
        "mergedRanges": {
          "type": "array",
          "items": { "type": "string", "pattern": "^[A-Z]+\\d+:[A-Z]+\\d+$" }
        },
        "namedRanges": {
          "type": "object",
          "patternProperties": {
            "^.*$": { "type": "string" }
          }
        },
        "comments": {
          "type": "object",
          "patternProperties": {
            "^[A-Z]+\\d+$": {
              "type": "array",
              "items": { "$ref": "#/definitions/Comment" }
            }
          }
        },
        "dataValidations": {
          "type": "array",
          "items": { "$ref": "#/definitions/DataValidation" }
        },
        "conditionalFormats": {
          "type": "array",
          "items": { "$ref": "#/definitions/ConditionalFormat" }
        },
        "properties": { "$ref": "#/definitions/SheetProperties" }
      }
    },
    "Cell": {
      "type": "object",
      "properties": {
        "raw": { "type": ["string", "number", "boolean", "null"] },
        "formula": { "type": "string", "pattern": "^=.*" },
        "dataType": { "enum": ["string", "number", "boolean", "date", "formula", "error"] },
        "computed": { "$ref": "#/definitions/ComputedValue" },
        "numFmt": { "type": "string" },
        "style": { "$ref": "#/definitions/CellStyle" },
        "hyperlink": {
          "type": "object",
          "properties": {
            "url": { "type": "string" },
            "tooltip": { "type": "string" }
          },
          "required": ["url"]
        },
        "notes": { "type": "string" },
        "metadata": { "type": "object" },
        "readOnly": { "type": "boolean" },
        "commentIds": { "type": "array", "items": { "type": "string" } },
        "validationId": { "type": "string" },
        "arrayFormula": { "type": "boolean" },
        "spilledFrom": { "type": "string", "pattern": "^[A-Z]+\\d+$" }
      }
    },
    "ComputedValue": {
      "type": "object",
      "required": ["v", "ts"],
      "properties": {
        "v": { "type": ["string", "number", "boolean", "null"] },
        "t": { "enum": ["n", "s", "b", "e", "d"] },
        "ts": { "type": "string", "format": "date-time" },
        "hfVersion": { "type": "string" },
        "computedBy": { "type": "string" },
        "error": { "type": "string" }
      }
    },
    "CellStyle": {
      "type": "object",
      "properties": {
        "bold": { "type": "boolean" },
        "italic": { "type": "boolean" },
        "underline": { "type": "boolean" },
        "strikethrough": { "type": "boolean" },
        "color": { "type": "string" },
        "bgColor": { "type": "string" },
        "fontSize": { "type": "number" },
        "fontFamily": { "type": "string" },
        "alignment": {
          "type": "object",
          "properties": {
            "horizontal": { "enum": ["left", "center", "right", "justify"] },
            "vertical": { "enum": ["top", "middle", "bottom"] },
            "wrapText": { "type": "boolean" },
            "indent": { "type": "number" }
          }
        },
        "border": {
          "type": "object",
          "properties": {
            "top": { "$ref": "#/definitions/BorderStyle" },
            "bottom": { "$ref": "#/definitions/BorderStyle" },
            "left": { "$ref": "#/definitions/BorderStyle" },
            "right": { "$ref": "#/definitions/BorderStyle" }
          }
        }
      }
    },
    "BorderStyle": {
      "type": "object",
      "properties": {
        "style": { "enum": ["thin", "medium", "thick", "dashed", "dotted", "double"] },
        "color": { "type": "string" }
      }
    },
    "DataValidation": {
      "type": "object",
      "required": ["type"],
      "properties": {
        "id": { "type": "string" },
        "range": { "type": "string" },
        "type": { "enum": ["list", "whole", "decimal", "date", "textLength", "custom"] },
        "operator": { "enum": ["between", "notBetween", "equal", "notEqual", "greaterThan", "lessThan", "greaterThanOrEqual", "lessThanOrEqual"] },
        "values": { "type": "array", "items": { "type": "string" } },
        "formula1": { "type": "string" },
        "formula2": { "type": "string" },
        "showError": { "type": "boolean" },
        "errorTitle": { "type": "string" },
        "errorMessage": { "type": "string" },
        "showInputMessage": { "type": "boolean" },
        "inputTitle": { "type": "string" },
        "inputMessage": { "type": "string" }
      }
    },
    "ConditionalFormat": {
      "type": "object",
      "required": ["id", "range", "type"],
      "properties": {
        "id": { "type": "string" },
        "range": { "type": "string" },
        "type": { "enum": ["expression", "cellIs", "colorScale", "dataBar", "iconSet", "top10", "duplicateValues", "uniqueValues"] },
        "priority": { "type": "number" },
        "stopIfTrue": { "type": "boolean" },
        "formula": { "type": "string" },
        "operator": { "type": "string" },
        "values": { "type": "array" },
        "colorScale": {
          "type": "object",
          "properties": {
            "min": { "type": "string" },
            "mid": { "type": "string" },
            "max": { "type": "string" }
          }
        },
        "style": { "$ref": "#/definitions/CellStyle" }
      }
    },
    "Comment": {
      "type": "object",
      "required": ["id", "author", "text", "createdAt"],
      "properties": {
        "id": { "type": "string" },
        "author": { "type": "string" },
        "text": { "type": "string" },
        "createdAt": { "type": "string", "format": "date-time" },
        "modifiedAt": { "type": "string", "format": "date-time" },
        "resolved": { "type": "boolean" },
        "replies": { "type": "array", "items": { "$ref": "#/definitions/Comment" } }
      }
    },
    "SheetProperties": {
      "type": "object",
      "properties": {
        "tabColor": { "type": "string" },
        "defaultRowHeight": { "type": "number" },
        "defaultColWidth": { "type": "number" },
        "freeze": {
          "type": "object",
          "properties": {
            "row": { "type": "number" },
            "col": { "type": "number" }
          }
        },
        "zoom": { "type": "number" },
        "gridLines": { "type": "boolean" },
        "showHeaders": { "type": "boolean" },
        "rtl": { "type": "boolean" }
      }
    },
    "Action": {
      "type": "object",
      "required": ["id", "type", "timestamp", "sheetId", "payload"],
      "properties": {
        "id": { "type": "string" },
        "type": { "enum": ["editCell", "deleteCell", "insertRow", "deleteRow", "insertCol", "deleteCol", "merge", "unmerge", "setStyle", "setFormat", "setRange"] },
        "timestamp": { "type": "string", "format": "date-time" },
        "user": { "type": "string" },
        "sheetId": { "type": "string" },
        "payload": { "type": "object" },
        "inverse": { "$ref": "#/definitions/Action" }
      }
    }
  }
}

================
File: client/src/lib/workbook/sheet-metadata.test.ts
================
/**
 * Sheet Metadata Test (cols/rows)
 * Verify that cols and rows metadata are properly initialized and used
 */
⋮----
import { createWorkbook, addSheet, cloneWorkbook } from "./utils";
import type { SheetJSON, ColMetadata, RowMetadata } from "./types";
⋮----
/**
 * Test 1: Verify cols/rows initialization in createWorkbook
 */
function testColsRowsInitInCreateWorkbook(): void
⋮----
// Verify cols exists and is empty object
⋮----
// Verify rows exists and is empty object
⋮----
/**
 * Test 2: Verify cols/rows initialization in addSheet
 */
function testColsRowsInitInAddSheet(): void
⋮----
// Verify cols exists
⋮----
// Verify rows exists
⋮----
/**
 * Test 3: Add column metadata
 */
function testAddColumnMetadata(): void
⋮----
// Add column width for column 1 (A)
⋮----
// Add column width for column 2 (B)
⋮----
// Hide column 3 (C)
⋮----
// Verify column metadata
⋮----
/**
 * Test 4: Add row metadata
 */
function testAddRowMetadata(): void
⋮----
// Add row height for row 1
⋮----
// Add row height for row 2
⋮----
// Hide row 3
⋮----
// Verify row metadata
⋮----
/**
 * Test 5: Verify cols/rows persist through clone
 */
function testColsRowsClone(): void
⋮----
// Add metadata
⋮----
// Clone workbook
⋮----
// Verify cols preserved
⋮----
// Verify rows preserved
⋮----
/**
 * Test 6: Verify JSON serialization
 */
function testColsRowsSerialization(): void
⋮----
// Add metadata
⋮----
// Serialize
⋮----
// Verify structure survived
⋮----
/**
 * Test 7: Sparse storage behavior
 */
function testSparseStorage(): void
⋮----
// Only set metadata for specific columns/rows (non-sequential)
⋮----
// Verify sparse storage (only defined entries exist)
⋮----
// Verify undefined columns/rows return undefined
⋮----
// Verify defined entries are accessible
⋮----
/**
 * Run all tests
 */
export function runSheetMetadataTests(): void
⋮----
// Auto-run if imported in browser console

================
File: client/src/lib/workbook/test-runner.ts
================
/**
 * Test runner for workbook round-trip tests
 * 
 * Usage in browser console:
 * import('./src/lib/workbook/test-runner.ts').then(m => m.runTests())
 * 
 * Or add to dev app temporarily for visual testing
 */
⋮----
import { runRoundTripTest, runExcelJSRoundTripTest } from "./roundtrip.test";
⋮----
export async function runTests()
⋮----
// Test 1: SheetJS adapter
⋮----
// Test 2: ExcelJS adapter
⋮----
// Summary
⋮----
// Auto-run when imported

================
File: client/src/lib/workbook/test.ts
================
/**
 * Basic workbook JSON tests
 * Run these to verify core functionality
 */
⋮----
import {
  createWorkbook,
  addSheet,
  setCell,
  getCell,
  parseAddress,
  toAddress,
  getCellsInRange,
  getWorkbookStats,
  SheetJSAdapter,
  type Cell,
} from "./index";
⋮----
// Test 1: Create workbook
⋮----
// Test 2: Add cells
⋮----
// Test 3: Read cells
⋮----
// Test 4: Address conversion
⋮----
console.log("✓ A1 ->", parseAddress("A1")); // { row: 1, col: 1 }
console.log("✓ Z10 ->", parseAddress("Z10")); // { row: 10, col: 26 }
console.log("✓ AA1 ->", parseAddress("AA1")); // { row: 1, col: 27 }
console.log("✓ (1,1) ->", toAddress(1, 1)); // "A1"
console.log("✓ (10,26) ->", toAddress(10, 26)); // "Z10"
⋮----
// Test 5: Range operations
⋮----
console.log("✓ A1:B2 cells:", range); // ["A1", "A2", "B1", "B2"]
⋮----
// Test 6: Workbook stats
⋮----
// Test 7: Add merge
⋮----
// Test 8: Add styling
⋮----
// Test 9: Add second sheet
⋮----
// Test 10: Export/Import with SheetJS adapter
⋮----
async function testExportImport()
⋮----
// Export
⋮----
// Import
⋮----
// Verify formula preserved
⋮----
// Verify merge preserved

================
File: client/src/lib/workbook/TYPES_CHANGELOG.md
================
# Types.ts Finalization - MVP Focus

**Date:** October 14, 2025  
**Status:** ✅ Complete  
**Task:** Finalize types.ts schema for MVP with formula+computed pattern, HF integration, and action log

---

## Changes Made

### 1. **Added MVP Focus Documentation**
- Added header comment clarifying MVP scope vs Phase 2 features
- Marked experimental features with `@experimental` JSDoc tags

### 2. **Enhanced WorkbookJSON Root Structure**
- Added `WorkbookProperties` for workbook-level settings (defaultRowHeight, defaultColWidth, workbookView)
- Moved `namedRanges` to top level for clarity (workbook-scoped vs sheet-scoped)
- Simplified `actionLog` from nested object to flat array (easier iteration)
- Added `aiPlans` placeholder for future Plan/Act integration
- Enhanced `WorkbookMeta` with `locale` and `timezone` for proper date/number handling

### 3. **Refined SheetJSON Structure**
- Added clear comments for sparse storage pattern
- Reorganized features into MVP vs Phase 2 sections
- Clarified that `cells` uses address-based keys ("A1", "B2") for Excel compatibility

### 4. **Marked Phase 2 Features as Experimental**
- `ChartMetadata` - Deferred with note about PNG generation for export
- `PivotTableMetadata` - Deferred
- `ImageMetadata` - Deferred
- `ConditionalFormat` - Marked experimental (basic support only)

### 5. **Enhanced Export Adapter Interface**
- Added `ExportResult` type for tracking export warnings
- Added `extension` and `mimeType` fields to adapter interface
- Expanded `features` capability flags for better UI hints
- Added `formulaCache` capability (critical for Excel compatibility)

### 6. **Added Validation Types**
- `ValidationResult` for basic TypeScript validation
- `ValidationError` with JSONPath-like paths and severity levels
- Note: Deferred JSON Schema/Ajv validation to Phase 2

### 7. **Added Comprehensive Type Summary**
- Visual hierarchy diagram showing type relationships
- Critical patterns for MVP (formula+cache, address-based keys, HF integration)
- Clear list of deferred features
- Export adapter contracts

---

## Key Design Decisions

### ✅ **Keep: Formula + Computed Cache Pattern**
```typescript
{
  formula: "=SUM(A1:A10)",  // Source of truth
  computed: {
    v: 55,                   // Cached result
    ts: "2025-10-14...",     // When computed
    hfVersion: "2.7.0",      // Version that computed it
    computedBy: "client-123" // Who computed it
  }
}
```
**Rationale:** Enables fast UI rendering without re-computation while preserving user intent.

### ✅ **Keep: Address-Based Cell Keys**
```typescript
cells: {
  "A1": { raw: "Hello" },
  "B2": { formula: "=A1" }
}
```
**Rationale:** Direct Excel API compatibility, no coordinate translation overhead.

### ✅ **Keep: HyperFormula Internal Coordinates**
```typescript
hfInternal: {
  sheetId: 0,  // HF's 0-based sheet index
  row: 0,      // 0-based row
  col: 0,      // 0-based col
  formulaId: "xyz"
}
```
**Rationale:** Dramatically speeds up HF rehydration by storing internal representation.

### ✅ **Simplified: Action Log Structure**
**Before:** `{ actions: Action[], currentIndex: number, maxSize?: number }`  
**After:** `Action[]` (flat array)  
**Rationale:** Simpler iteration, pointer can live in UI state, easier serialization.

### ⚠️ **Deferred: Charts, Pivots, Images**
**Status:** Types defined but marked `@experimental`  
**Rationale:** Core spreadsheet functionality (formulas, merges, styles) is MVP. Visual features come after users validate core value.

### ⚠️ **Deferred: JSON Schema Validation**
**Status:** TypeScript-only validation for MVP  
**Rationale:** Adding Ajv + schema.json adds complexity. TypeScript catches 90% of issues. Add formal schema when handling user-uploaded files.

---

## Impact on Other Modules

### ✅ **No Breaking Changes to utils.ts**
Current utilities (`createWorkbook`, `setCell`, `getCell`) work with updated types without modification.

### ⚠️ **Minor Changes Needed:**
1. **adapters/sheetjs.ts** - Update to align with new `ExportAdapter` interface (add `extension`, `mimeType`)
2. **useWorkbook.ts** - Simplify `actionLog` handling (flat array instead of nested object)
3. **jsonWorkbook.ts** - This old schema needs migration guide (already flagged in roadmap)

---

## Next Steps (From Todo List)

1. ✅ **Finalize types.ts** - COMPLETE
2. 🔄 **Complete SheetJS adapter** - Use new `ExportAdapter` interface
3. 🔄 **Integrate HyperFormula** - Use `hfInternal` and `computed` fields
4. 🔄 **Implement applyOperations** - Use simplified `Action[]` structure
5. 🔄 **Basic undo/redo** - Leverage `inverse` actions

---

## Testing Requirements

### Must-Pass Before Merge:
- [x] TypeScript compilation (no errors)
- [ ] SheetJS adapter exports with `f` and `v` fields
- [ ] Round-trip test (create → export → import → verify)
- [ ] HyperFormula integration test (formula → compute → cache)

### Phase 2:
- [ ] ExcelJS adapter (rich formatting)
- [ ] Large workbook performance (50k cells)
- [ ] Collaborative editing (websocket sync)

---

## Documentation

**Primary Docs:**
- `types.ts` - Inline JSDoc comments with examples
- `README.md` - User-facing API guide
- `MIGRATION.md` - Migration from old schema (when needed)

**This File:**
- Technical changelog for engineering team
- Design decision rationale
- Impact analysis

---

**Status:** Types are MVP-ready. No breaking changes to existing code. Ready to proceed with adapter and HF integration.

================
File: client/src/lib/workbook/types.ts
================
/**
 * Workbook JSON Schema v1.0
 * Single source of truth for spreadsheet data, formulas, and metadata
 * 
 * MVP Focus: Core spreadsheet functionality (cells, formulas, merges, styles)
 * Phase 2: Charts, pivots, images, advanced conditional formatting
 */
⋮----
// ============================================================================
// Core Cell Types
// ============================================================================
⋮----
export type CellDataType = "string" | "number" | "boolean" | "date" | "formula" | "error";
export type SheetJSType = "n" | "s" | "b" | "e" | "d"; // number, string, bool, error, date
⋮----
export interface BorderStyle {
  style?: "thin" | "medium" | "thick" | "dashed" | "dotted" | "double";
  color?: string;
}
⋮----
export interface CellStyle {
  bold?: boolean;
  italic?: boolean;
  underline?: boolean;
  strikethrough?: boolean;
  color?: string;
  bgColor?: string;
  fontSize?: number;
  fontFamily?: string;
  alignment?: {
    horizontal?: "left" | "center" | "right" | "justify";
    vertical?: "top" | "middle" | "bottom";
    wrapText?: boolean;
    indent?: number;
  };
  border?: {
    top?: BorderStyle;
    bottom?: BorderStyle;
    left?: BorderStyle;
    right?: BorderStyle;
  };
}
⋮----
export interface ComputedValue {
  v: string | number | boolean | null; // computed result
  t?: SheetJSType; // SheetJS type hint
  ts: string; // timestamp (ISO)
  hfVersion?: string; // HyperFormula version used
  computedBy?: string; // "client-uuid" | "server" | "hf-x.y.z"
  error?: string; // error message if formula failed
}
⋮----
v: string | number | boolean | null; // computed result
t?: SheetJSType; // SheetJS type hint
ts: string; // timestamp (ISO)
hfVersion?: string; // HyperFormula version used
computedBy?: string; // "client-uuid" | "server" | "hf-x.y.z"
error?: string; // error message if formula failed
⋮----
export interface HyperFormulaInternal {
  sheetId: number; // HF's internal sheet ID (0-based)
  row: number; // 0-based row index
  col: number; // 0-based col index
  formulaId?: string; // optional HF formula ID for batch updates
}
⋮----
sheetId: number; // HF's internal sheet ID (0-based)
row: number; // 0-based row index
col: number; // 0-based col index
formulaId?: string; // optional HF formula ID for batch updates
⋮----
export interface Cell {
  // User input
  raw?: string | number | boolean | null; // what user typed
  dataType?: CellDataType; // explicit data type

  // Formula info
  formula?: string; // formula string (canonical source of truth)
  hfInternal?: HyperFormulaInternal; // HyperFormula's internal representation

  // Computed cache (optional but recommended)
  computed?: ComputedValue;

  // Formatting
  numFmt?: string; // number format code: "#,##0.00", "mm/dd/yyyy"
  style?: CellStyle; // visual styling
  hyperlink?: { url: string; tooltip?: string };

  // Metadata
  notes?: string; // plain note (not rendered as comment)
  metadata?: Record<string, any>; // extensible metadata
  readOnly?: boolean;

  // Advanced features (optional)
  validation?: DataValidation; // cell-level validation reference
  conditionalFormatRuleId?: string; // reference to sheet-level rule
  arrayFormula?: boolean; // true if anchor of spilled array
  spilledFrom?: string; // "A1" — if part of spilled range
}
⋮----
// User input
raw?: string | number | boolean | null; // what user typed
dataType?: CellDataType; // explicit data type
⋮----
// Formula info
formula?: string; // formula string (canonical source of truth)
hfInternal?: HyperFormulaInternal; // HyperFormula's internal representation
⋮----
// Computed cache (optional but recommended)
⋮----
// Formatting
numFmt?: string; // number format code: "#,##0.00", "mm/dd/yyyy"
style?: CellStyle; // visual styling
⋮----
// Metadata
notes?: string; // plain note (not rendered as comment)
metadata?: Record<string, any>; // extensible metadata
⋮----
// Advanced features (optional)
validation?: DataValidation; // cell-level validation reference
conditionalFormatRuleId?: string; // reference to sheet-level rule
arrayFormula?: boolean; // true if anchor of spilled array
spilledFrom?: string; // "A1" — if part of spilled range
⋮----
// ============================================================================
// Sheet-level Types
// ============================================================================
⋮----
export interface RowMetadata {
  height?: number;
  hidden?: boolean;
}
⋮----
export interface ColMetadata {
  width?: number;
  hidden?: boolean;
}
⋮----
export interface DataValidation {
  id?: string;
  range?: string; // "A1:B10"
  type: "list" | "whole" | "decimal" | "date" | "textLength" | "custom";
  operator?: "between" | "notBetween" | "equal" | "notEqual" | "greaterThan" | "lessThan" | "greaterThanOrEqual" | "lessThanOrEqual";
  values?: string[]; // for list validation
  formula1?: string;
  formula2?: string;
  showError?: boolean;
  errorTitle?: string;
  errorMessage?: string;
  showInputMessage?: boolean;
  inputTitle?: string;
  inputMessage?: string;
}
⋮----
range?: string; // "A1:B10"
⋮----
values?: string[]; // for list validation
⋮----
/**
 * Conditional formatting rule (Phase 2)
 * @experimental - Defer to Phase 2 for MVP
 */
export interface ConditionalFormat {
  id: string;
  range: string; // "A1:C10"
  type: "expression" | "cellIs" | "colorScale" | "dataBar" | "iconSet" | "top10" | "duplicateValues" | "uniqueValues";
  priority?: number;
  stopIfTrue?: boolean;
  // Rule-specific config
  formula?: string;
  operator?: string;
  values?: any[];
  colorScale?: { min?: string; mid?: string; max?: string };
  style?: CellStyle;
}
⋮----
range: string; // "A1:C10"
⋮----
// Rule-specific config
⋮----
export interface Comment {
  id: string;
  author: string;
  text: string;
  createdAt: string;
  modifiedAt?: string;
  resolved?: boolean;
  replies?: Comment[];
}
⋮----
/**
 * Chart metadata (Phase 2)
 * @experimental - Defer to Phase 2 for MVP
 * Note: When implementing, consider server-side PNG generation for XLSX export
 */
export interface ChartMetadata {
  id: string;
  type: "line" | "bar" | "pie" | "scatter" | "area" | "combo";
  title?: string;
  dataRange: string; // "Sheet1!A1:C10"
  xAxis?: { title?: string; range?: string };
  yAxis?: { title?: string; range?: string };
  series?: Array<{ name: string; range: string; color?: string }>;
  position?: { anchor: string; width?: number; height?: number };
  options?: Record<string, any>;
}
⋮----
dataRange: string; // "Sheet1!A1:C10"
⋮----
/**
 * Pivot table metadata (Phase 2)
 * @experimental - Defer to Phase 2 for MVP
 */
export interface PivotTableMetadata {
  id: string;
  name: string;
  sourceRange: string; // "Sheet1!A1:D100"
  targetCell: string; // "A1"
  rows?: string[];
  cols?: string[];
  values?: Array<{ field: string; aggregation: "sum" | "count" | "average" | "min" | "max" }>;
  filters?: Record<string, any>;
}
⋮----
sourceRange: string; // "Sheet1!A1:D100"
targetCell: string; // "A1"
⋮----
/**
 * Image metadata (Phase 2)
 * @experimental - Defer to Phase 2 for MVP
 */
export interface ImageMetadata {
  id: string;
  anchor: {
    type: "oneCell" | "twoCell";
    from: string; // "A1"
    to?: string; // "C3" for twoCell
  };
  dataUrl?: string; // base64 or external URL
  alt?: string;
  metadata?: Record<string, any>;
}
⋮----
from: string; // "A1"
to?: string; // "C3" for twoCell
⋮----
dataUrl?: string; // base64 or external URL
⋮----
export interface SheetProperties {
  tabColor?: string;
  defaultRowHeight?: number;
  defaultColWidth?: number;
  freeze?: { row?: number; col?: number }; // freeze rows above/cols left of
  zoom?: number; // 100 = 100%
  gridLines?: boolean;
  showHeaders?: boolean;
  rtl?: boolean; // right-to-left
}
⋮----
freeze?: { row?: number; col?: number }; // freeze rows above/cols left of
zoom?: number; // 100 = 100%
⋮----
rtl?: boolean; // right-to-left
⋮----
export interface SheetProtection {
  enabled: boolean;
  passwordHash?: string; // hashed password (server-side verification recommended)
  allowFormatCells?: boolean;
  allowFormatColumns?: boolean;
  allowFormatRows?: boolean;
  allowInsertColumns?: boolean;
  allowInsertRows?: boolean;
  allowDeleteColumns?: boolean;
  allowDeleteRows?: boolean;
  allowSort?: boolean;
  allowFilter?: boolean;
}
⋮----
passwordHash?: string; // hashed password (server-side verification recommended)
⋮----
export interface SheetJSON {
  id: string; // Persistent UUID
  name: string;
  visible?: boolean; // Default: true
  grid?: { rowCount: number; colCount: number }; // Default: 1000x50
  
  // Cell data (sparse storage - only non-empty cells)
  rows?: Record<number, RowMetadata>; // 1-based row numbers
  cols?: Record<number, ColMetadata>; // 1-based col numbers
  cells?: Record<string, Cell>; // "A1", "B2", etc. (address-based for Excel compat)
  
  // Core features (MVP)
  mergedRanges?: string[]; // ["A1:B2", "C3:D4"]
  namedRanges?: Record<string, string>; // Sheet-scoped: { "MyRange": "A1:B10" }
  comments?: Record<string, Comment[]>; // { "A1": [comment1, comment2] }
  
  // Advanced features (MVP - basic support)
  filters?: { range?: string; columns?: Record<number, any> };
  sorts?: Array<{ column: string; ascending: boolean }>;
  dataValidations?: DataValidation[];
  
  // Phase 2 features (deferred)
  conditionalFormats?: ConditionalFormat[]; // @experimental
  charts?: ChartMetadata[]; // @experimental
  pivots?: PivotTableMetadata[]; // @experimental
  images?: ImageMetadata[]; // @experimental
  
  // Sheet settings
  protection?: SheetProtection;
  properties?: SheetProperties;
}
⋮----
id: string; // Persistent UUID
⋮----
visible?: boolean; // Default: true
grid?: { rowCount: number; colCount: number }; // Default: 1000x50
⋮----
// Cell data (sparse storage - only non-empty cells)
rows?: Record<number, RowMetadata>; // 1-based row numbers
cols?: Record<number, ColMetadata>; // 1-based col numbers
cells?: Record<string, Cell>; // "A1", "B2", etc. (address-based for Excel compat)
⋮----
// Core features (MVP)
mergedRanges?: string[]; // ["A1:B2", "C3:D4"]
namedRanges?: Record<string, string>; // Sheet-scoped: { "MyRange": "A1:B10" }
comments?: Record<string, Comment[]>; // { "A1": [comment1, comment2] }
⋮----
// Advanced features (MVP - basic support)
⋮----
// Phase 2 features (deferred)
conditionalFormats?: ConditionalFormat[]; // @experimental
charts?: ChartMetadata[]; // @experimental
pivots?: PivotTableMetadata[]; // @experimental
images?: ImageMetadata[]; // @experimental
⋮----
// Sheet settings
⋮----
// ============================================================================
// Workbook-level Types
// ============================================================================
⋮----
export interface WorkbookMeta {
  title?: string;
  author?: string;
  company?: string;
  createdAt: string; // ISO 8601 timestamp
  modifiedAt: string; // ISO 8601 timestamp
  description?: string;
  tags?: string[];
  locale?: string; // e.g., "en-US" for date/number formatting
  timezone?: string; // e.g., "America/New_York" for date serialization
}
⋮----
createdAt: string; // ISO 8601 timestamp
modifiedAt: string; // ISO 8601 timestamp
⋮----
locale?: string; // e.g., "en-US" for date/number formatting
timezone?: string; // e.g., "America/New_York" for date serialization
⋮----
export interface WorkbookProperties {
  defaultRowHeight?: number; // Default: 21
  defaultColWidth?: number; // Default: 100
  workbookView?: {
    firstSheet?: number; // 0-based index
    activeTab?: number; // 0-based index
  };
}
⋮----
defaultRowHeight?: number; // Default: 21
defaultColWidth?: number; // Default: 100
⋮----
firstSheet?: number; // 0-based index
activeTab?: number; // 0-based index
⋮----
/**
 * Workbook-scoped named ranges and settings
 */
export interface GlobalSettings {
  namedRanges?: Record<string, string>; // workbook-scoped: { "TaxRate": "Sheet1!$A$1" }
  externalLinks?: Array<{ id: string; path: string; type: string }>; // @experimental Phase 2
  scripts?: Array<{ id: string; name: string; code: string }>; // @experimental Phase 2
  theme?: Record<string, any>; // @experimental Phase 2
}
⋮----
namedRanges?: Record<string, string>; // workbook-scoped: { "TaxRate": "Sheet1!$A$1" }
externalLinks?: Array<{ id: string; path: string; type: string }>; // @experimental Phase 2
scripts?: Array<{ id: string; name: string; code: string }>; // @experimental Phase 2
theme?: Record<string, any>; // @experimental Phase 2
⋮----
/**
 * HyperFormula computed cache and dependency tracking
 * Critical for performance - avoids recomputing entire workbook on every change
 */
export interface ComputedCache {
  hfCache?: Record<string, ComputedValue>; // "Sheet1!A1" -> computed value
  dependencyGraph?: Record<string, string[]>; // "Sheet1!A1" -> ["Sheet1!B1", "Sheet1!C1"]
}
⋮----
hfCache?: Record<string, ComputedValue>; // "Sheet1!A1" -> computed value
dependencyGraph?: Record<string, string[]>; // "Sheet1!A1" -> ["Sheet1!B1", "Sheet1!C1"]
⋮----
/**
 * Action for undo/redo system
 * Each action is atomic and includes its inverse for rollback
 */
export interface Action {
  id: string; // UUID
  type: "editCell" | "deleteCell" | "insertRow" | "deleteRow" | "insertCol" | "deleteCol" | "merge" | "unmerge" | "setStyle" | "setFormat" | "setRange";
  timestamp: string; // ISO 8601
  user?: string; // User ID or session ID
  sheetId: string; // Which sheet was affected
  payload: any; // Type-specific data (row, col, value, etc.)
  inverse?: Action; // Inverse action for undo (same structure, opposite effect)
}
⋮----
id: string; // UUID
⋮----
timestamp: string; // ISO 8601
user?: string; // User ID or session ID
sheetId: string; // Which sheet was affected
payload: any; // Type-specific data (row, col, value, etc.)
inverse?: Action; // Inverse action for undo (same structure, opposite effect)
⋮----
/**
 * Action log for undo/redo stack
 * Maintains pointer for current position in history
 */
export interface ActionLog {
  actions: Action[]; // Ordered list of actions (oldest to newest)
  currentIndex: number; // Pointer for undo/redo (-1 = no actions, 0 = first action)
  maxSize?: number; // Max actions to keep in memory (default: 100, archive older)
}
⋮----
actions: Action[]; // Ordered list of actions (oldest to newest)
currentIndex: number; // Pointer for undo/redo (-1 = no actions, 0 = first action)
maxSize?: number; // Max actions to keep in memory (default: 100, archive older)
⋮----
/**
 * Root workbook structure
 * This is the single source of truth for all spreadsheet data
 */
export interface WorkbookJSON {
  schemaVersion: string; // "1.0" - bump on breaking changes
  workbookId: string; // Persistent UUID
  meta: WorkbookMeta; // Metadata (title, author, timestamps, etc.)
  sheets: SheetJSON[]; // Array of sheets (at least one required)
  workbookProperties?: WorkbookProperties; // Workbook-level settings
  namedRanges?: Record<string, string>; // Workbook-scoped named ranges (moved from global for clarity)
  computed?: ComputedCache; // HyperFormula cache and dependency graph
  actionLog?: Action[]; // Undo/redo stack (simplified from nested ActionLog for easier iteration)

  // Export metadata
  exportWarnings?: string[]; // Warnings from export operations about unsupported features

  // Phase 2 features (deferred)
  aiPlans?: Record<string, any>; // @experimental - Plan/Act design integration
  global?: GlobalSettings; // @experimental - External links, scripts, themes
}
⋮----
schemaVersion: string; // "1.0" - bump on breaking changes
workbookId: string; // Persistent UUID
meta: WorkbookMeta; // Metadata (title, author, timestamps, etc.)
sheets: SheetJSON[]; // Array of sheets (at least one required)
workbookProperties?: WorkbookProperties; // Workbook-level settings
namedRanges?: Record<string, string>; // Workbook-scoped named ranges (moved from global for clarity)
computed?: ComputedCache; // HyperFormula cache and dependency graph
actionLog?: Action[]; // Undo/redo stack (simplified from nested ActionLog for easier iteration)
⋮----
// Export metadata
exportWarnings?: string[]; // Warnings from export operations about unsupported features
⋮----
// Phase 2 features (deferred)
aiPlans?: Record<string, any>; // @experimental - Plan/Act design integration
global?: GlobalSettings; // @experimental - External links, scripts, themes
⋮----
// ============================================================================
// Export Adapter Interface
// ============================================================================
⋮----
/**
 * Result of export validation
 * Tracks which features were successfully exported and which were skipped
 */
export interface ExportResult {
  buffer: ArrayBuffer;
  warnings?: string[]; // Features that couldn't be exported
  metadata?: {
    exportedSheets: number;
    exportedCells: number;
    exportedFormulas: number;
    skippedFeatures?: string[]; // e.g., ["charts", "pivots"]
  };
}
⋮----
warnings?: string[]; // Features that couldn't be exported
⋮----
skippedFeatures?: string[]; // e.g., ["charts", "pivots"]
⋮----
/**
 * Export adapter interface for different file formats
 * Allows swapping export engines without touching core code
 */
export interface ExportAdapter {
  /**
   * Export workbook to binary format (XLSX, CSV, etc.)
   * Should preserve formulas (f) and computed values (v) for Excel compatibility
   */
  export(workbook: WorkbookJSON): Promise<ArrayBuffer>;

  /**
   * Import binary format to workbook JSON
   * Should preserve formulas and attempt to extract computed values
   */
  import(data: Blob | ArrayBuffer): Promise<WorkbookJSON>;

  /**
   * Adapter name for debugging and UI display
   */
  readonly name: string;

  /**
   * File extension (e.g., "xlsx", "csv")
   */
  readonly extension: string;

  /**
   * MIME type for downloads
   */
  readonly mimeType: string;

  /**
   * Supported features (for capability detection and UI hints)
   * MVP focus: formulas, merges, basic styles
   */
  readonly features: {
    formulas: boolean; // Can preserve formula strings
    formulaCache: boolean; // Can write computed values alongside formulas
    styles: boolean; // Font, fill, borders, alignment
    merges: boolean; // Merged cell ranges
    comments: boolean; // Cell comments/notes
    dataValidations: boolean; // Data validation rules
    conditionalFormats: boolean; // Conditional formatting (Phase 2)
    charts: boolean; // Chart objects (Phase 2)
    images: boolean; // Embedded images (Phase 2)
    namedRanges: boolean; // Named range support
    columnWidths: boolean; // Column width preservation
    rowHeights: boolean; // Row height preservation
  };
}
⋮----
/**
   * Export workbook to binary format (XLSX, CSV, etc.)
   * Should preserve formulas (f) and computed values (v) for Excel compatibility
   */
export(workbook: WorkbookJSON): Promise<ArrayBuffer>;
⋮----
/**
   * Import binary format to workbook JSON
   * Should preserve formulas and attempt to extract computed values
   */
import(data: Blob | ArrayBuffer): Promise<WorkbookJSON>;
⋮----
/**
   * Adapter name for debugging and UI display
   */
⋮----
/**
   * File extension (e.g., "xlsx", "csv")
   */
⋮----
/**
   * MIME type for downloads
   */
⋮----
/**
   * Supported features (for capability detection and UI hints)
   * MVP focus: formulas, merges, basic styles
   */
⋮----
formulas: boolean; // Can preserve formula strings
formulaCache: boolean; // Can write computed values alongside formulas
styles: boolean; // Font, fill, borders, alignment
merges: boolean; // Merged cell ranges
comments: boolean; // Cell comments/notes
dataValidations: boolean; // Data validation rules
conditionalFormats: boolean; // Conditional formatting (Phase 2)
charts: boolean; // Chart objects (Phase 2)
images: boolean; // Embedded images (Phase 2)
namedRanges: boolean; // Named range support
columnWidths: boolean; // Column width preservation
rowHeights: boolean; // Row height preservation
⋮----
// ============================================================================
// Validation and Error Types
// ============================================================================
⋮----
/**
 * Validation result for workbook structure
 * Used by basic TypeScript validation (no JSON Schema for MVP)
 */
export interface ValidationResult {
  valid: boolean;
  errors?: ValidationError[];
}
⋮----
export interface ValidationError {
  path: string; // JSONPath-like: "sheets[0].cells.A1.formula"
  message: string;
  severity: "error" | "warning";
}
⋮----
path: string; // JSONPath-like: "sheets[0].cells.A1.formula"
⋮----
// ============================================================================
// Type Summary & Usage Guidelines
// ============================================================================
⋮----
/**
 * MVP TYPE HIERARCHY
 * 
 * WorkbookJSON (root)
 * ├── schemaVersion: "1.0"
 * ├── workbookId: UUID
 * ├── meta: WorkbookMeta (title, author, timestamps, locale)
 * ├── sheets: SheetJSON[] (at least one required)
 * │   └── SheetJSON
 * │       ├── id: UUID (persistent)
 * │       ├── name: string
 * │       ├── cells: Record<string, Cell> (address-based: "A1", "B2")
 * │       │   └── Cell
 * │       │       ├── raw?: user input
 * │       │       ├── formula?: "=SUM(A1:A10)"
 * │       │       ├── computed?: ComputedValue (HF cache)
 * │       │       ├── numFmt?: Excel format code
 * │       │       ├── style?: CellStyle
 * │       │       └── hfInternal?: HyperFormula coords
 * │       ├── mergedRanges?: ["A1:B2"]
 * │       ├── rows?: Record<number, RowMetadata>
 * │       ├── cols?: Record<number, ColMetadata>
 * │       └── properties?: SheetProperties
 * ├── computed?: ComputedCache (HF cache + dependency graph)
 * ├── actionLog?: Action[] (undo/redo stack)
 * └── namedRanges?: Record<string, string>
 * 
 * CRITICAL PATTERNS FOR MVP:
 * 
 * 1. Formula + Computed Cache Pattern
 *    - ALWAYS store user formula in `cell.formula`
 *    - ALWAYS store computed result in `cell.computed.v`
 *    - ALWAYS write both `f` and `v` to XLSX for Excel compatibility
 *    - Track `hfVersion` and `computedBy` for cache invalidation
 * 
 * 2. Address-Based Cell Keys
 *    - Use Excel notation: "A1", "B2", "AA100"
 *    - Direct mapping to SheetJS/ExcelJS APIs
 *    - No coordinate translation overhead
 * 
 * 3. HyperFormula Integration
 *    - Store HF internals in `cell.hfInternal` for fast rehydration
 *    - Maintain workbook-level cache in `computed.hfCache`
 *    - Track dependencies in `computed.dependencyGraph`
 * 
 * 4. Action Log for Undo/Redo
 *    - Each Action includes `payload` and optional `inverse`
 *    - Array of actions (oldest to newest)
 *    - Apply inverse to undo, reapply forward to redo
 * 
 * 5. Sparse Storage
 *    - Only store non-empty cells in `cells` Record
 *    - Only store non-default row heights in `rows`
 *    - Only store non-default col widths in `cols`
 * 
 * DEFERRED TO PHASE 2:
 * - Charts, pivots, images (marked @experimental)
 * - Advanced conditional formatting
 * - External links and scripts
 * - JSON Schema validation (use TypeScript only for MVP)
 * - Server-side validation and permissions
 * - Compression and performance optimization
 * 
 * EXPORT ADAPTER CONTRACTS:
 * - SheetJS: Basic export (formulas, merges, widths, heights)
 * - ExcelJS: Rich export (styles, comments, validations) - Phase 2
 * - Must preserve formula strings AND computed values
 * - Must handle features gracefully (skip unsupported, add warnings)
 */

================
File: client/src/lib/workbook/undo.ts
================
/**
 * Undo/Redo System
 * 
 * This module implements undo/redo functionality using the action log.
 * 
 * Design:
 * - Action log is a flat array of actions
 * - Each action has an optional inverse for undo
 * - Undo applies the inverse action
 * - Redo reapplies the forward action
 * - Branch on new action after undo (discard redo stack)
 */
⋮----
import type { WorkbookJSON, Action } from "./types";
import type { HydrationResult } from "./hyperformula";
import { applyOperations } from "./operations";
import type { AnyOperation, ApplyOptions } from "./operations";
⋮----
// ============================================================================
// Undo/Redo Functions
// ============================================================================
⋮----
/**
 * Result of undo/redo operation
 */
export interface UndoRedoResult {
  success: boolean;
  action: Action | null; // The action that was undone/redone
  error?: string;
}
⋮----
action: Action | null; // The action that was undone/redone
⋮----
/**
 * Undo the last action
 * 
 * Applies the inverse of the last action in the log.
 * 
 * @param workbook - Target workbook (modified in place)
 * @param options - Apply options (hydration for recompute)
 * @returns UndoRedoResult
 */
export function undo(
  workbook: WorkbookJSON,
  options: { hydration?: HydrationResult } = {}
): UndoRedoResult
⋮----
// Initialize action log if needed
⋮----
// Check if there are actions to undo
⋮----
// Get last action
⋮----
// Check if action has inverse
⋮----
// Apply inverse action
⋮----
// Convert inverse action to operation
⋮----
// Apply operation (skip adding to log, skip validation)
⋮----
// Temporarily remove last action before applying inverse
⋮----
// Apply inverse without creating new action
⋮----
// Restore action if failed
⋮----
// Update metadata
⋮----
/**
 * Redo the last undone action
 * 
 * Note: In the simplified action log, we don't track redo stack separately.
 * This implementation would need enhancement for a full redo system.
 * For MVP, we focus on undo.
 * 
 * @param workbook - Target workbook
 * @param options - Apply options
 * @returns UndoRedoResult
 */
export function redo(
  workbook: WorkbookJSON,
  options: { hydration?: HydrationResult } = {}
): UndoRedoResult
⋮----
// For MVP, redo is not implemented yet
// Would require tracking redo stack separately or using cursor-based navigation
⋮----
/**
 * Check if undo is available
 */
export function canUndo(workbook: WorkbookJSON): boolean
⋮----
/**
 * Check if redo is available
 */
export function canRedo(workbook: WorkbookJSON): boolean
⋮----
// For MVP, redo is not implemented
⋮----
/**
 * Get undo stack depth
 */
export function getUndoDepth(workbook: WorkbookJSON): number
⋮----
/**
 * Clear action log (cannot undo after this)
 */
export function clearActionLog(workbook: WorkbookJSON): void
⋮----
// ============================================================================
// Helper Functions
// ============================================================================
⋮----
/**
 * Convert Action to Operation
 * 
 * This bridges the Action log format to the Operation format
 * used by applyOperations().
 */
function actionToOperation(action: Action): AnyOperation | null
⋮----
/**
 * Apply inverse action directly without creating new action
 * 
 * This is used by undo() to avoid adding inverse actions to the log.
 */
function applyInverseDirectly(
  workbook: WorkbookJSON,
  inverseAction: Action,
  options: ApplyOptions
):
⋮----
// Convert to operation
⋮----
// Apply operation without adding to log
// We do this by temporarily saving and restoring the action log
⋮----
skipValidation: true, // Skip validation for inverse
⋮----
// Restore log (but don't add the inverse action)
⋮----
// ============================================================================
// Action Log Management
// ============================================================================
⋮----
/**
 * Get recent actions from log
 */
export function getRecentActions(
  workbook: WorkbookJSON,
  limit: number = 10
): Action[]
⋮----
/**
 * Get action by ID
 */
export function getActionById(
  workbook: WorkbookJSON,
  actionId: string
): Action | null
⋮----
/**
 * Get actions by sheet
 */
export function getActionsBySheet(
  workbook: WorkbookJSON,
  sheetId: string,
  limit?: number
): Action[]
⋮----
/**
 * Get actions by user
 */
export function getActionsByUser(
  workbook: WorkbookJSON,
  user: string,
  limit?: number
): Action[]
⋮----
/**
 * Get action log statistics
 */
export function getActionLogStats(workbook: WorkbookJSON):
⋮----
oldestAction?: string; // timestamp
newestAction?: string; // timestamp
⋮----
// Count by type
⋮----
// Count by sheet
⋮----
// Count by user
⋮----
// Get timestamps

================
File: client/src/lib/workbook/useWorkbook.ts
================
/**
 * React hook for managing workbook state
 * Integrates with new WorkbookJSON schema
 */
⋮----
import { useState, useCallback, useMemo, useEffect, useRef } from 'react';
import type { WorkbookJSON, SheetJSON, Cell } from './types';
import {
  createWorkbook,
  addSheet,
  getCell,
  getWorkbookStats,
  cloneWorkbook,
} from './utils';
import { applyOperations, type EditCellOp, type DeleteCellOp } from './operations';
import { undo, redo, canUndo, canRedo } from './undo';
import { hydrateHFFromWorkbook, recomputeAndPatchCache, type HydrationResult } from './hyperformula';
⋮----
export interface UseWorkbookOptions {
  initialWorkbook?: WorkbookJSON;
  autoSave?: boolean;
  onSave?: (workbook: WorkbookJSON) => void | Promise<void>;
  enableFormulas?: boolean; // Enable HyperFormula integration (default: true)
}
⋮----
enableFormulas?: boolean; // Enable HyperFormula integration (default: true)
⋮----
export interface UseWorkbookReturn {
  // State
  workbook: WorkbookJSON;
  currentSheetId: string;
  currentSheet: SheetJSON | undefined;
  
  // Actions
  setCell: (address: string, cell: Cell) => void;
  getCellValue: (address: string) => Cell | undefined;
  clearCell: (address: string) => void;
  
  // Sheet management
  addNewSheet: (name?: string) => SheetJSON;
  switchSheet: (sheetId: string) => void;
  renameSheet: (sheetId: string, name: string) => void;
  
  // Workbook operations
  updateWorkbook: (updater: (wb: WorkbookJSON) => WorkbookJSON) => void;
  resetWorkbook: (newWorkbook?: WorkbookJSON) => void;
  
  // Undo/Redo
  undoLast: () => void;
  redoLast: () => void;
  canUndoAction: boolean;
  canRedoAction: boolean;
  
  // Formula computation
  recompute: () => void;
  isComputing: boolean;
  
  // Utilities
  stats: ReturnType<typeof getWorkbookStats>;
  isDirty: boolean;
  save: () => Promise<void>;
}
⋮----
// State
⋮----
// Actions
⋮----
// Sheet management
⋮----
// Workbook operations
⋮----
// Undo/Redo
⋮----
// Formula computation
⋮----
// Utilities
⋮----
export function useWorkbook(options: UseWorkbookOptions =
⋮----
// HyperFormula instance (persistent across renders)
⋮----
const enableFormulas = options.enableFormulas !== false; // Default: true
⋮----
// Undo/Redo state
⋮----
// Update workbook and mark as dirty
⋮----
// Set cell using operations for undo/redo support
⋮----
// Get cell value
⋮----
// Clear cell using operations for undo/redo support
⋮----
// Add new sheet
⋮----
// Fallback to current sheet
⋮----
// Switch sheet
⋮----
// Rename sheet
⋮----
// Reset workbook
⋮----
// Undo last action
⋮----
// Redo last action
⋮----
// Recompute formulas
⋮----
// Hydrate or reuse HF instance
⋮----
// Recompute and patch cache
⋮----
// Trigger re-render with updated computed values
⋮----
// Save workbook
⋮----
// Initialize HF instance on mount
⋮----
// Cleanup on unmount
⋮----
}, []); // Only run on mount/unmount
⋮----
// Recompute when workbook changes (debounced)
⋮----
}, 300); // Debounce 300ms
⋮----
// Auto-save
// useEffect(() => {
//   if (options.autoSave && isDirty) {
//     const timer = setTimeout(() => {
//       save();
//     }, 2000); // Auto-save after 2s of inactivity
//     return () => clearTimeout(timer);
//   }
// }, [isDirty, options.autoSave, save]);

================
File: client/src/lib/workbook/utils.ts
================
/**
 * Workbook JSON utilities
 * Core functions for creating, manipulating, and validating workbooks
 */
⋮----
import type { WorkbookJSON, SheetJSON, Cell } from "./types";
⋮----
/**
 * Generate a simple UUID v4
 */
export function generateId(): string
⋮----
/**
 * Create a new empty workbook with default settings
 */
export function createWorkbook(title = "Workbook"): WorkbookJSON
⋮----
/**
 * Add a new sheet to the workbook
 */
export function addSheet(
  workbook: WorkbookJSON,
  name?: string
): SheetJSON
⋮----
/**
 * Get sheet by ID
 */
export function getSheet(workbook: WorkbookJSON, sheetId: string): SheetJSON | undefined
⋮----
/**
 * Get sheet by name
 */
export function getSheetByName(workbook: WorkbookJSON, name: string): SheetJSON | undefined
⋮----
/**
 * Set cell value in a sheet
 */
export function setCell(
  workbook: WorkbookJSON,
  sheetId: string,
  address: string,
  cell: Cell
): void
⋮----
/**
 * Get cell from a sheet
 */
export function getCell(
  workbook: WorkbookJSON,
  sheetId: string,
  address: string
): Cell | undefined
⋮----
/**
 * Delete cell from a sheet
 */
export function deleteCell(
  workbook: WorkbookJSON,
  sheetId: string,
  address: string
): void
⋮----
/**
 * Parse cell address to row/col (1-based)
 * "A1" -> { row: 1, col: 1 }
 * "Z10" -> { row: 10, col: 26 }
 */
export function parseAddress(address: string):
⋮----
/**
 * Convert row/col (1-based) to cell address
 * { row: 1, col: 1 } -> "A1"
 * { row: 10, col: 26 } -> "Z10"
 */
export function toAddress(row: number, col: number): string
⋮----
/**
 * Parse range string to start/end addresses
 * "A1:C3" -> { start: "A1", end: "C3" }
 */
export function parseRange(range: string):
⋮----
/**
 * Get all cell addresses in a range
 * "A1:B2" -> ["A1", "A2", "B1", "B2"]
 */
export function getCellsInRange(range: string): string[]
⋮----
/**
 * Check if address is within range
 */
export function isInRange(address: string, range: string): boolean
⋮----
/**
 * Validate workbook JSON structure
 */
export function validateWorkbook(workbook: any): workbook is WorkbookJSON
⋮----
// Basic sheet validation
⋮----
/**
 * Deep clone a workbook
 */
export function cloneWorkbook(workbook: WorkbookJSON): WorkbookJSON
⋮----
/**
 * Get workbook statistics
 */
export function getWorkbookStats(workbook: WorkbookJSON)
⋮----
/**
 * Convert 0-based row/col (HyperFormula) to 1-based
 */
export function hfToAddress(row: number, col: number): string
⋮----
/**
 * Convert 1-based row/col to 0-based (HyperFormula)
 */
export function addressToHf(address: string):

================
File: client/src/lib/workbook/validator.test.ts
================
/**
 * Workbook Validator Tests
 * Tests JSON Schema validation functionality
 */
⋮----
import { validateWorkbookObject } from "./validator";
import sampleWorkbook from "./samples/simple.json";
⋮----
schemaVersion: 1.0, // Should be string, not number
⋮----
// Missing workbookId, meta, sheets

================
File: client/src/lib/workbook/validator.ts
================
/**
 * Workbook JSON Validator
 * Uses JSON Schema validation with Ajv
 */
⋮----
import type { WorkbookJSON } from "./types";
import schema from "./schema.json";
⋮----
interface ValidationResult {
  valid: boolean;
  errors?: ValidationError[];
}
⋮----
interface ValidationError {
  path: string;
  message: string;
  severity: "error" | "warning";
}
⋮----
async function getAjv()
⋮----
export async function validateWorkbook(workbook: any): Promise<ValidationResult>
⋮----
// Compile schema if not already compiled
⋮----
// Convert Ajv errors to our format
⋮----
export async function validateWorkbookFile(filePath: string): Promise<ValidationResult>
⋮----
// Browser environment - can't read files directly
⋮----
// Read file (in Node.js environment)
⋮----
export async function validateWorkbookString(jsonString: string): Promise<ValidationResult>
⋮----
// CLI interface for Node.js
export async function runValidatorCLI()
⋮----
// For browser usage - validate from object
export async function validateWorkbookObject(workbook: WorkbookJSON): Promise<ValidationResult>

================
File: client/src/lib/workbook/workbook-properties.test.ts
================
/**
 * Workbook Properties Test
 * Verify that workbookProperties are properly initialized and used
 */
⋮----
import { createWorkbook, addSheet, cloneWorkbook } from "./utils";
import type { WorkbookJSON } from "./types";
⋮----
/**
 * Test 1: Verify workbookProperties initialization
 */
function testWorkbookPropertiesInit(): void
⋮----
// Verify workbookProperties exists
⋮----
// Verify default values
⋮----
// Verify workbookView
⋮----
/**
 * Test 2: Verify workbookProperties persist through clone
 */
function testWorkbookPropertiesClone(): void
⋮----
// Verify properties persist
⋮----
/**
 * Test 3: Verify workbookProperties can be modified
 */
function testWorkbookPropertiesModification(): void
⋮----
// Modify properties
⋮----
// Verify changes
⋮----
/**
 * Test 4: Verify activeTab updates when adding sheets
 */
function testWorkbookPropertiesWithMultipleSheets(): void
⋮----
// Add more sheets
⋮----
// Update activeTab to point to second sheet
⋮----
// Verify firstSheet remains 0
⋮----
/**
 * Test 5: Verify JSON serialization/deserialization
 */
function testWorkbookPropertiesSerialization(): void
⋮----
// Serialize to JSON
⋮----
// Deserialize
⋮----
// Verify workbookProperties survived
⋮----
/**
 * Run all tests
 */
export function runWorkbookPropertiesTests(): void
⋮----
// Auto-run if imported in browser console

================
File: client/src/main.tsx
================
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App.tsx';
import { ThemeProvider } from '../ui/ThemeProvider';

================
File: client/src/README.md
================
# Nexcell v.20 - UI Implementation

A modern, minimalistic AI-powered spreadsheet editor with a Vercel-inspired design.

## 🚀 Quick Start

```powershell
# Install dependencies
npm install

# Start development server
npm run dev

# Build for production
npm run build
```

## 📁 Project Structure

```
src/
├── components/
│   ├── ui/              # Base UI components (Button, Input, Card)
│   │   ├── Button.tsx
│   │   ├── Input.tsx
│   │   ├── Card.tsx
│   │   └── index.ts
│   ├── layout/          # Layout components
│   │   ├── Header.tsx
│   │   ├── MainLayout.tsx
│   │   └── index.ts
│   ├── chat/            # Chat interface
│   │   ├── ChatInterface.tsx
│   │   └── index.ts
│   └── canvas/          # Spreadsheet canvas
│       ├── CanvasRenderer.tsx
│       ├── FormulaBar.tsx
│       └── index.ts
├── lib/
│   ├── utils.ts         # Utility functions
│   └── types.ts         # TypeScript types
├── App.tsx              # Main app component
├── main.tsx             # App entry point
└── index.css            # Global styles
```

## 🎨 Design System

Following the Vercel-inspired design principles:

- **Typography**: Inter font family
- **Colors**: Grayscale-focused with blue accent
- **Spacing**: 4px base scale
- **Shadows**: Subtle elevation
- **Components**: Built with Tailwind CSS

See `DESIGN_SYSTEM.md` for complete design specifications.

## 🧩 Key Features (Phase 1)

✅ **Layout**
- Clean header with editable workbook name
- Split-view layout (Chat + Spreadsheet)
- Responsive design

✅ **Chat Interface**
- Message display (user, assistant, system)
- Auto-resizing textarea
- Keyboard shortcuts (Enter to send, Shift+Enter for new line)

✅ **Spreadsheet Canvas**
- Virtualized grid (TanStack Virtual)
- Formula bar
- Cell selection and editing
- Keyboard navigation (arrow keys)
- Column/row headers

✅ **Styling**
- Tailwind CSS
- Custom design tokens
- Inter font
- Clean, minimal aesthetic

## 🎯 Current State

This is the **Phase 1: Foundation** implementation:

- Basic layout structure ✅
- Header with workbook name ✅
- Chat interface (display only) ✅
- Simple grid display ✅
- Basic styling with Tailwind ✅
- Cell editing ✅
- Formula bar ✅
- Keyboard navigation ✅

## 📋 Next Steps (Phase 2+)

Coming soon:
- [ ] Backend integration for chat
- [ ] AI action previews
- [ ] Apply/cancel flow
- [ ] Undo/redo
- [ ] Command palette
- [ ] Context menus
- [ ] Advanced keyboard shortcuts
- [ ] Cell formatting
- [ ] Formula evaluation

## 🔧 Technologies

- **React 19** - UI framework
- **TypeScript** - Type safety
- **Tailwind CSS 4** - Styling
- **TanStack Virtual** - Grid virtualization
- **Lucide React** - Icons
- **Vite** - Build tool

## 📚 Documentation

- `UI.md` - UI specifications and component reference
- `DESIGN_SYSTEM.md` - Design system documentation
- Component props documented inline with TypeScript

## 🎨 Customization

Design tokens are defined in `src/index.css`:

```css
@theme {
  --color-accent-500: #3b82f6;
  /* ... more tokens */
}
```

Modify these to customize the look and feel.

## 🐛 Known Issues

- Cell editing blur behavior needs refinement
- Formula evaluation not yet implemented (displays raw input)
- No data persistence yet
- Chat is mock only (no backend connection)

## 📄 License

MIT License

================
File: client/src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: client/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
⋮----
// Light Green Primary Palette (Mint/Fresh)
⋮----
50: '#F0FFF9',    // Very light mint tint
100: '#CCFFF0',   // Lighter mint
200: '#99FFE1',   // Light mint
300: '#6DD5C4',   // Soft mint
400: '#4AEDC4',   // Bright mint (main primary)
500: '#3DD4B0',   // Medium mint
600: '#2FB89A',   // Deeper mint
700: '#2A9B82',   // Dark mint
800: '#23806D',   // Darker mint
900: '#1F6A5C',   // Deep mint
⋮----
// Complementary Accent Colors
⋮----
// Neutrals - Enhanced for light theme
⋮----
25: '#FEFEFE',    // Almost white
50: '#F8F9FA',    // Off-white background
100: '#F3F4F6',   // Light gray
200: '#E5E7EB',   // Border gray
300: '#D1D5DB',   // Muted border
400: '#9CA3AF',   // Placeholder text
500: '#6B7280',   // Secondary text
600: '#4B5563',   // Body text
700: '#374151',   // Dark text
800: '#1F2937',   // Headings
900: '#111827',   // Almost black
950: '#0A0A0A',   // Pure black
⋮----
// Semantic colors with new palette

================
File: client/tsconfig.app.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Path Aliases */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

================
File: client/tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: client/tsconfig.node.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: client/UI_CHECKLIST.md
================
# Nexcell v.20 UI - Implementation Checklist

## ✅ Phase 1: Foundation (COMPLETED)

### Layout & Structure
- [x] Basic app shell with header
- [x] Split-view layout (Chat + Canvas)
- [x] Responsive layout structure
- [x] Header with logo and workbook name
- [x] Editable workbook name (click to edit)
- [x] User menu placeholder

### Chat Interface
- [x] Message list with scroll
- [x] User/Assistant/System message types
- [x] Message styling with proper colors
- [x] Auto-resizing textarea
- [x] Send button with icon
- [x] Keyboard shortcuts (Enter to send, Shift+Enter for newline)
- [x] Loading state support
- [x] Auto-scroll to latest message

### Spreadsheet Canvas
- [x] Virtualized grid (TanStack Virtual)
- [x] Column headers (A, B, C...)
- [x] Row headers (1, 2, 3...)
- [x] Cell rendering
- [x] Cell selection (click)
- [x] Cell editing (double-click)
- [x] Keyboard navigation (arrow keys)
- [x] Formula bar display
- [x] Formula bar editing

### Styling & Design
- [x] Tailwind CSS setup
- [x] Custom design tokens
- [x] Inter font integration
- [x] Color palette (grayscale + blue accent)
- [x] Focus styles
- [x] Hover states
- [x] Clean, minimal aesthetic

### Core Components
- [x] Button component (variants: primary, secondary, ghost, danger)
- [x] Input component
- [x] Card component
- [x] Header component
- [x] ChatInterface component
- [x] CanvasRenderer component
- [x] FormulaBar component
- [x] MainLayout component

### TypeScript & Types
- [x] Core type definitions
- [x] Message type
- [x] CellData type
- [x] WorkbookData type
- [x] Component prop types

### Utilities
- [x] `cn()` utility for class merging
- [x] Path aliases (@/* imports)
- [x] Vite configuration

## 🚧 Phase 2: Interactivity (TODO)

### Cell Editing
- [ ] Formula evaluation (integrate formula engine)
- [ ] Cell validation
- [ ] Error display
- [ ] Copy/paste support
- [ ] Multi-cell selection (drag)
- [ ] Selection indicators

### Chat Features
- [ ] Connect to backend API
- [ ] Streaming message support (SSE)
- [ ] Action proposals
- [ ] Action badges
- [ ] Preview button
- [ ] Apply/Cancel buttons

### Navigation
- [ ] Command palette (Ctrl/Cmd+K)
- [ ] Quick find (Ctrl/Cmd+F)
- [ ] Sheet tabs (future)
- [ ] Jump to cell

## 🔮 Phase 3: AI Integration (TODO)

### AI Actions
- [ ] Action preview modal
- [ ] Before/after diff view
- [ ] Confidence score display
- [ ] Affected cells count
- [ ] Apply action
- [ ] Cancel action
- [ ] Explain action

### State Management
- [ ] Undo/redo stack
- [ ] Action log
- [ ] Version history
- [ ] Auto-save

### Backend Integration
- [ ] API client setup
- [ ] Chat endpoint integration
- [ ] Action endpoints
- [ ] Error handling
- [ ] Loading states

## 🎨 Phase 4: Polish (TODO)

### UX Enhancements
- [ ] Context menus (right-click)
- [ ] Tooltips
- [ ] Keyboard shortcut hints
- [ ] Empty states
- [ ] Error boundaries

### Performance
- [ ] Web Worker for formulas
- [ ] Optimize re-renders
- [ ] Lazy loading
- [ ] Code splitting
- [ ] Performance monitoring

### Accessibility
- [ ] ARIA labels
- [ ] Keyboard-only navigation
- [ ] Screen reader support
- [ ] Focus management
- [ ] Color contrast audit

### Documentation
- [ ] Storybook setup
- [ ] Component stories
- [ ] Interactive documentation
- [ ] API documentation
- [ ] User guide

## 📊 Current Status

**Progress**: Phase 1 Complete (Foundation)  
**Next Up**: Backend integration for chat  
**Blockers**: None  

**Lines of Code**: ~1000+  
**Components**: 10+  
**Features Working**: Cell editing, navigation, chat UI  

## 🎯 Success Metrics

- [x] UI loads without errors
- [x] Chat interface functional
- [x] Grid renders 100x20 cells smoothly
- [x] Keyboard navigation works
- [x] Cell editing works
- [ ] 60fps scroll performance (needs testing)
- [ ] <16ms frame time (needs profiling)

## 🐛 Known Issues

1. Cell editing blur behavior could be smoother
2. Formula bar doesn't evaluate formulas yet (phase 2)
3. No data persistence (needs backend)
4. Chat is mock-only (needs API)
5. No undo/redo yet (phase 3)

## 📝 Notes

- UI is intentionally simple to start - will add features incrementally
- Following mobile-first responsive principles
- Using TanStack Virtual for performance
- All components are TypeScript strict mode
- Design follows DESIGN_SYSTEM.md specifications

---

**Last Updated**: October 13, 2025  
**Version**: v.20 (Phase 1)  
**Status**: ✅ Foundation Complete

================
File: client/UI.md
================
# UI.md — Nexcell v.20

> A concise reference for designers and engineers that specifies layout, components, interactions, and behavior for the AI spreadsheet editor.

---

## 1. Purpose

Keep the UI deterministic, fast, and predictable. Chat-driven actions on the left, spreadsheet canvas on the right, minimal distractions. This doc is the single source for UI behavior and component responsibilities.

---

## 2. Principles

* Desktop-first (web), responsive where reasonable (chat panel collapses on narrow screens)
* Keep 60fps scroll/render target for the canvas
* Use Tailwind + custom components as primitives
* Clean, Vercel-inspired aesthetic with subtle colors and ample whitespace
* Progressive enhancement: start simple, add features incrementally

---

## 3. High-level Layout

```
┌─────────────────────────────────────────────────────────────┐
│ Header: Logo | Workbook name | User menu                    │
├─────────────────┬───────────────────────────────────────────┤
│ Chat Panel      │ Spreadsheet Canvas                        │
│ (left — 30%)    │ (right — 70%)                             │
│ - Message list  │ - Virtualized grid                        │
│ - Input area    │ - Formula bar                             │
│                 │ - Column/row headers                      │
└─────────────────┴───────────────────────────────────────────┘
```

---

## 4. Component Inventory (MVP)

### 4.1 App Shell / Header
* Displays workbook name (editable inline)
* User menu (profile, settings, sign out)
* Clean, minimal design with proper spacing

### 4.2 ChatInterface (left)
* Message list (scrollable, with user/assistant distinction)
* Composer: auto-resize textarea
* Clean message bubbles with Inter typography
* Support for system messages and action confirmations

### 4.3 CanvasRenderer (right)
* Virtualized grid using TanStack Virtual
* FormulaBar: shows active cell value/formula
* Column/Row headers: click to select
* Cell states: normal, selected, editing
* Context menu support (future enhancement)

### 4.4 StatusBar (bottom)
* Last saved indicator
* Connection status
* Error notifications

---

## 5. Visual & Design Tokens

Following our existing DESIGN_SYSTEM.md:

* **Typography**: Inter font family
  - Base: 14px
  - Small: 12px
  - Large: 16-18px for headers

* **Colors** (grayscale-focused):
  - Surface: `gray-50` to `gray-100`
  - Text: `gray-900` (primary), `gray-500` (secondary)
  - Accent: `accent-500` (blue)
  - Borders: `gray-200`

* **Spacing**: 4px base scale (4, 8, 12, 16, 24, 32, 48)

* **Shadows**: Subtle Vercel-style shadows for elevation

---

## 6. Interaction Patterns (Phase 1)

### 6.1 Chat → Display flow
1. User types request in chat
2. Message displays in conversation
3. (Future: AI actions and previews)

### 6.2 Cell editing
* Click cell → selection
* Enter → edit mode
* Escape → discard
* Commit (Enter) → apply change

### 6.3 Navigation
* Arrow keys: navigate cells
* Click: select cell
* Drag: extend selection (future)

---

## 7. Keyboard Shortcuts (Phase 1)

* `Enter`: commit cell edit / send chat message
* `Esc`: cancel cell edit / close modal
* `Arrow keys`: navigate cells
* Additional shortcuts to be added incrementally

---

## 8. Component Props (simplified)

```typescript
// FormulaBar
interface FormulaBarProps {
  value: string;
  onCommit: (value: string) => void;
  onCancel: () => void;
}

// CanvasRenderer
interface CanvasRendererProps {
  data: CellData[][];
  viewport: Viewport;
  onCellEdit: (row: number, col: number, value: string) => void;
}

// ChatInterface
interface ChatInterfaceProps {
  messages: Message[];
  onSendMessage: (content: string) => void;
  isLoading?: boolean;
}
```

---

## 9. Accessibility

* Keyboard-operable interactive elements
* Proper ARIA roles and labels
* 4.5:1 contrast for text
* Focus indicators on all interactive elements

---

## 10. Performance Requirements

* Virtualization: TanStack Virtual with overscan 3
* Target <16ms per frame for visible updates
* Lazy-load heavy components after initial render
* Optimize re-renders with proper React memoization

---

## 11. Files Structure

```
src/
├── components/
│   ├── ui/              # Base UI components (Button, Input, Card)
│   ├── layout/          # Layout components (Header, MainLayout)
│   ├── chat/            # Chat-related components
│   ├── canvas/          # Spreadsheet canvas components
│   └── common/          # Shared utilities
├── lib/
│   ├── utils.ts         # Utility functions (cn, etc.)
│   └── types.ts         # TypeScript types
├── hooks/               # Custom React hooks
├── stores/              # Zustand state stores
└── App.tsx              # Main app entry
```

---

## 12. Implementation Phases

### Phase 1: Foundation (Current)
- [ ] Basic layout structure
- [ ] Header with workbook name
- [ ] Chat interface (display only)
- [ ] Simple grid display
- [ ] Basic styling with Tailwind

### Phase 2: Interactivity
- [ ] Cell editing
- [ ] Formula bar
- [ ] Message sending
- [ ] Navigation

### Phase 3: AI Integration
- [ ] Chat with backend
- [ ] Action previews
- [ ] Apply/cancel flow
- [ ] Undo/redo

### Phase 4: Polish
- [ ] Command palette
- [ ] Advanced keyboard shortcuts
- [ ] Context menus
- [ ] Performance optimizations

---

## 13. Development Guidelines

* Start with static layouts and mock data
* Build components in isolation
* Test keyboard navigation early
* Keep components small and focused
* Use TypeScript strictly
* Follow the existing DESIGN_SYSTEM.md

---

## 14. Notes

* This is a living document - update as features are implemented
* Prioritize working software over perfect documentation
* Keep the design simple and clean
* Reference DESIGN_SYSTEM.md for visual specifications

================
File: client/ui/ThemeProvider.tsx
================
import { type ReactNode, useEffect } from 'react';
import tokens from './tokens.json';
⋮----
export function ThemeProvider(

================
File: client/ui/tokens.json
================
{
  "fontFamily": "Inter",
  "space": { "xs":4, "sm":8, "md":16, "lg":24 },
  "colors": { "surface":"#f6f7fb", "muted":"#9aa3b2", "aiAccent":"#2563eb", "danger":"#ef4444" }
}

================
File: client/vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'
⋮----
// https://vite.dev/config/

================
File: mcp.json
================
{
  "mcpServers": {
    "context7": {
      "url": "https://mcp.context7.com/mcp",
      "headers": {
        "CONTEXT7_API_KEY": "YOUR_API_KEY"
      }
    },
    "tavily": {
      "url": "https://mcp.tavily.com/mcp",
      "headers": {
        "TAVILY_API_KEY": "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"
      }
    }
  }
}

================
File: .gitignore
================
# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Dependencies
node_modules/
.pnp/
.pnp.js

# Build outputs
dist/
build/
out/
.next/
.vite/

# Testing
coverage/
.nyc_output/

# IDE
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
.idea/
*.swp
*.swo
*~
.DS_Store

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# OS
Thumbs.db
.DS_Store

# Temporary files
*.tmp
*.temp
.cache/

# Prisma
prisma/dev.db
prisma/dev.db-journal

# Sentry
.sentryclirc

# Editor directories
.idea
.vscode
*.sublime-project
*.sublime-workspace

# Misc
.turbo
.vercel





================================================================
End of Codebase
================================================================
